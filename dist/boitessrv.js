/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("module");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CachedKeyDecoder\": () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DecodeError\": () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataViewIndexOutOfBoundsError\": () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   \"Decoder\": () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n    };\n    /**\n     * @throws {DecodeError}\n     * @throws {RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + (0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \" + (0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \" + (0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n        }\n        this.stack.push({\n            type: 1 /* MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n        }\n        this.stack.push({\n            type: 0 /* ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.TEXT_DECODER_THRESHOLD) {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeTD)(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeJs)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_MAX_DEPTH\": () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   \"DEFAULT_INITIAL_BUFFER_SIZE\": () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   \"Encoder\": () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.getUint8Array = function () {\n        return this.bytes.subarray(0, this.pos);\n    };\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.getUint8Array();\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \" + depth);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \" + size);\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \" + size);\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \" + size);\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \" + size);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExtData\": () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExtensionCodec\": () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultDecodeOptions\": () => (/* binding */ defaultDecodeOptions),\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"decodeMulti\": () => (/* binding */ decodeMulti)\n/* harmony export */ });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encode(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EXT_TIMESTAMP\": () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   \"encodeTimeSpecToTimestamp\": () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   \"encodeDateToTimeSpec\": () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   \"encodeTimestampExtension\": () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   \"decodeTimestampToTimeSpec\": () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   \"decodeTimestampExtension\": () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   \"timestampExtension\": () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UINT32_MAX\": () => (/* binding */ UINT32_MAX),\n/* harmony export */   \"setUint64\": () => (/* binding */ setUint64),\n/* harmony export */   \"setInt64\": () => (/* binding */ setInt64),\n/* harmony export */   \"getInt64\": () => (/* binding */ getInt64),\n/* harmony export */   \"getUint64\": () => (/* binding */ getUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"prettyByte\": () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ensureUint8Array\": () => (/* binding */ ensureUint8Array),\n/* harmony export */   \"createDataView\": () => (/* binding */ createDataView)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"utf8Count\": () => (/* binding */ utf8Count),\n/* harmony export */   \"utf8EncodeJs\": () => (/* binding */ utf8EncodeJs),\n/* harmony export */   \"TEXT_ENCODER_THRESHOLD\": () => (/* binding */ TEXT_ENCODER_THRESHOLD),\n/* harmony export */   \"utf8EncodeTE\": () => (/* binding */ utf8EncodeTE),\n/* harmony export */   \"utf8DecodeJs\": () => (/* binding */ utf8DecodeJs),\n/* harmony export */   \"TEXT_DECODER_THRESHOLD\": () => (/* binding */ TEXT_DECODER_THRESHOLD),\n/* harmony export */   \"utf8DecodeTD\": () => (/* binding */ utf8DecodeTD)\n/* harmony export */ });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://boitessrv/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs?");

/***/ }),

/***/ "./src/api.mjs":
/*!*********************!*\
  !*** ./src/api.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"PINGTO\": () => (/* binding */ PINGTO),\n/* harmony export */   \"E_BRK\": () => (/* binding */ E_BRK),\n/* harmony export */   \"E_WS\": () => (/* binding */ E_WS),\n/* harmony export */   \"E_DB\": () => (/* binding */ E_DB),\n/* harmony export */   \"E_BRO\": () => (/* binding */ E_BRO),\n/* harmony export */   \"E_SRV\": () => (/* binding */ E_SRV),\n/* harmony export */   \"X_SRV\": () => (/* binding */ X_SRV),\n/* harmony export */   \"F_BRO\": () => (/* binding */ F_BRO),\n/* harmony export */   \"F_SRV\": () => (/* binding */ F_SRV),\n/* harmony export */   \"AppExc\": () => (/* binding */ AppExc),\n/* harmony export */   \"EXBRK\": () => (/* binding */ EXBRK),\n/* harmony export */   \"EXPS\": () => (/* binding */ EXPS),\n/* harmony export */   \"SIZEAV\": () => (/* binding */ SIZEAV),\n/* harmony export */   \"SIZEGR\": () => (/* binding */ SIZEGR),\n/* harmony export */   \"INDEXT\": () => (/* binding */ INDEXT)\n/* harmony export */ });\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n\r\n\r\nconst version = '1'\r\n\r\nconst PINGTO = 10000 // en secondes\r\n\r\nconst E_BRK = -1 // Interruption volontaire de l'opération\r\nconst E_WS = -2 // Toutes erreurs de réseau\r\nconst E_DB = -3 // Toutes erreurs d'accès à la base locale\r\nconst E_BRO = -4 // Erreur inattendue trappée sur le browser\r\nconst E_SRV = -5 // Erreur inattendue trappée sur le serveur\r\nconst X_SRV = -6 // Erreur fonctionnelle trappée sur le serveur transmise en exception\r\nconst F_BRO = -7 // Erreur fonctionnelle trappée sur le browser\r\nconst F_SRV = -8 // Erreur fonctionnelle trappée sur le serveur transmise en résultat\r\n\r\nclass AppExc {\r\n  constructor (code, message, stack) {\r\n    this.code = code\r\n    this.message = message || '?'\r\n    if (stack) this.stack = stack\r\n  }\r\n\r\n  toString () {\r\n    return JSON.stringify(this)\r\n  }\r\n}\r\n\r\nconst EXBRK = new AppExc(E_BRK, 'Interruption volontaire')\r\nconst EXPS = new AppExc(F_BRO, 'La phrase secrète a changé depuis l\\'authentification du comptE Déconnexion et reconnexion requise')\r\n\r\nconst SIZEAV = 5\r\nconst SIZEGR = 3\r\n\r\nconst INDEXT = {\r\n  SECRET: 0,\r\n  AVATAR: 1,\r\n  CONTACT: 2,\r\n  RENCONTRE: 3,\r\n  PARRAIN: 4,\r\n  GROUPE: 1,\r\n  MEMBRE: 2\r\n}\r\n\r\n/*\r\n- `versions` (id) : table des prochains numéros de versions (actuel et dernière sauvegarde) et autres singletons clé / valeur\r\n- `avgrvq` (id) : volumes et quotas d'un avatar ou groupe\r\n- `avrsa` (id) : clé publique d'un avatar\r\n\r\n_**Tables aussi persistantes sur le client (IDB)**_\r\n\r\n- `compte` (id) : authentification et données d'un compte\r\n- `avatar` (id) : données d'un avatar et liste de ses contacts\r\n- `invitgr` (id, ni) : invitation reçue par un avatar à devenir membre d'un groupe\r\n- `contact` (id, nc) : données d'un contact d'un avatar\r\n- `rencontre` (prh) id : communication par A de son nom complet à un avatar B non connu de A dans l'application\r\n- `parrain` (pph) id : parrainage par un avatar A de la création d'un nouveau compte\r\n- `groupe` (id) : données du groupe et liste de ses avatars, invités ou ayant été pressentis, un jour à être membre.\r\n- `membre` (id, im) : données d'un membre du groupe\r\n- `secret` (id, ns) : données d'un secret d'un avatar ou groupe\r\n*/\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavatar',\r\n  cols: ['id', 'v', 'st', 'vcv', 'dds', 'cva', 'lgrk', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavgrq',\r\n  cols: ['id', 'q1', 'q2', 'qm1', 'qm2', 'v1', 'v2', 'vm1', 'vm2', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavrsa',\r\n  cols: ['id', 'clepub', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcompte',\r\n  cols: ['id', 'v', 'dds', 'dpbh', 'pcbh', 'kx', 'mack', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowprefs',\r\n  cols: ['id', 'v', 'mapk', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcontact',\r\n  cols: ['id', 'ic', 'v', 'st', 'q1', 'q2', 'qm1', 'qm2', 'ardc', 'datap', 'datak', 'mc', 'infok', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowgroupe',\r\n  cols: ['id', 'v', 'dds', 'st', 'stxy', 'cvg', 'mcg', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowinvitgr',\r\n  cols: ['id', 'ni', 'datap']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowmembre',\r\n  cols: ['id', 'im', 'v', 'st', 'vote', 'q1', 'q2', 'mc', 'infok', 'datag', 'ardg', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowparrain',\r\n  cols: ['pph', 'id', 'v', 'dlv', 'st', 'q1', 'q2', 'qm1', 'qm2', 'datak', 'datax', 'data2k', 'ardc', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowrencontre',\r\n  cols: ['prh', 'id', 'v', 'dlv', 'st', 'datak', 'nomax', 'nombx', 'ardx', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowsecret',\r\n  cols: ['id', 'ns', 'ic', 'v', 'st', 'ora', 'v1', 'v2', 'mc', 'txts', 'mpjs', 'dups', 'refs', 'vsh']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowversions',\r\n  cols: ['id', 'v']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcv',\r\n  cols: ['id', 'vcv', 'st', 'cva']\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'syncList',\r\n  cols: ['sessionId', 'dh', 'rowItems']\r\n})\r\n\n\n//# sourceURL=webpack://boitessrv/./src/api.mjs?");

/***/ }),

/***/ "./src/base64.mjs":
/*!************************!*\
  !*** ./src/base64.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"byteLength\": () => (/* binding */ byteLength),\n/* harmony export */   \"toByteArray\": () => (/* binding */ toByteArray),\n/* harmony export */   \"fromByteArray\": () => (/* binding */ fromByteArray)\n/* harmony export */ });\n/* eslint-disable no-var */\r\n\r\n/*\r\nhttps://github.com/beatgammit/base64-js/blob/master/index.js\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n*/\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\n// Support decoding URL-safe base64 strings, as Node.js does.\r\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction getLens (b64) {\r\n  var len = b64.length\r\n\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // Trim off extra bytes after placeholder bytes are found\r\n  // See: https://github.com/beatgammit/base64-js/issues/42\r\n  var validLen = b64.indexOf('=')\r\n  if (validLen === -1) validLen = len\r\n\r\n  var placeHoldersLen = validLen === len\r\n    ? 0\r\n    : 4 - (validLen % 4)\r\n\r\n  return [validLen, placeHoldersLen]\r\n}\r\n\r\n// base64 is 4/3 + up to two characters of the original data\r\nfunction byteLength (b64) {\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction _byteLength (b64, validLen, placeHoldersLen) {\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var tmp\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n\r\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n  var curByte = 0\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  var len = placeHoldersLen > 0\r\n    ? validLen - 4\r\n    : validLen\r\n\r\n  var i\r\n  for (i = 0; i < len; i += 4) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 18) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n      revLookup[b64.charCodeAt(i + 3)]\r\n    arr[curByte++] = (tmp >> 16) & 0xFF\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 2) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 2) |\r\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 1) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 10) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] +\r\n    lookup[num >> 12 & 0x3F] +\r\n    lookup[num >> 6 & 0x3F] +\r\n    lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp =\r\n      ((uint8[i] << 16) & 0xFF0000) +\r\n      ((uint8[i + 1] << 8) & 0xFF00) +\r\n      (uint8[i + 2] & 0xFF)\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 2] +\r\n      lookup[(tmp << 4) & 0x3F] +\r\n      '=='\r\n    )\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 10] +\r\n      lookup[(tmp >> 4) & 0x3F] +\r\n      lookup[(tmp << 2) & 0x3F] +\r\n      '='\r\n    )\r\n  }\r\n\r\n  return parts.join('')\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/base64.mjs?");

/***/ }),

/***/ "./src/crypto.mjs":
/*!************************!*\
  !*** ./src/crypto.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crypt\": () => (/* binding */ crypt),\n/* harmony export */   \"u8ToB64\": () => (/* binding */ u8ToB64),\n/* harmony export */   \"b64ToU8\": () => (/* binding */ b64ToU8)\n/* harmony export */ });\n/* harmony import */ var _base64_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64.mjs */ \"./src/base64.mjs\");\n/* harmony import */ var _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.mjs */ \"./src/webcrypto.mjs\");\n\r\n\r\n\r\n\r\nconst crypt = { pbkfd: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.pbkfd, sha256: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.sha256, random: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.random, crypter: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypter, decrypter: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypter, decrypterStr: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypterStr, genKeyPair: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.genKeyPair, crypterRSA: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypterRSA, decrypterRSA: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypterRSA, concat: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.concat, u8ToB64, b64ToU8, rnd6, hash, hashBin, int2base64, bigToU8, u8ToBig, u8ToInt, intToU8, sidToId, idToSid, test1, test2 }\r\n\r\nfunction u8ToB64 (u8, url) {\r\n  const s = (0,_base64_mjs__WEBPACK_IMPORTED_MODULE_0__.fromByteArray)(u8)\r\n  return !url ? s : s.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\r\n}\r\n\r\nfunction b64ToU8 (s) {\r\n  const diff = s.length % 4\r\n  let x = s\r\n  if (diff) {\r\n    const pad = '===='.substring(0, 4 - diff)\r\n    x = s + pad\r\n  }\r\n  return (0,_base64_mjs__WEBPACK_IMPORTED_MODULE_0__.toByteArray)(x.replace(/-/g, '+').replace(/_/g, '/'))\r\n}\r\n\r\nfunction rnd6 () { return u8ToInt((0,_webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.random)(6)) }\r\n\r\nfunction hash (str, big = false, b64 = false, seed = 0) {\r\n  // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\r\n  for (let i = 0, ch; i < str.length; i++) {\r\n    ch = str.charCodeAt(i)\r\n    h1 = Math.imul(h1 ^ ch, 2654435761)\r\n    h2 = Math.imul(h2 ^ ch, 1597334677)\r\n  }\r\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909)\r\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909)\r\n  const r = big ? 4294967296n * BigInt(h2) + BigInt(h1) : 4294967296 * (2097151 & h2) + (h1 >>> 0)\r\n  if (Number.isSafeInteger(r)) {\r\n    console.log(r)\r\n  }\r\n  return b64 ? int2base64(r) : r\r\n}\r\n\r\nfunction hashBin (str, big = false, b64 = false, seed = 0) {\r\n  // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\r\n  for (let i = 0, ch; i < str.length; i++) {\r\n    ch = str[i]\r\n    h1 = Math.imul(h1 ^ ch, 2654435761)\r\n    h2 = Math.imul(h2 ^ ch, 1597334677)\r\n  }\r\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909)\r\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909)\r\n  const r = big ? 4294967296n * BigInt(h2) + BigInt(h1) : 4294967296 * (2097151 & h2) + (h1 >>> 0)\r\n  return b64 ? int2base64(r) : r\r\n}\r\n\r\nconst c64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\r\nfunction int2base64 (n) {\r\n  let r = '', x = n, i\r\n  const b = typeof n !== 'number'\r\n  while (x) {\r\n    i = b ? Number(x % 64n) : x % 64\r\n    r += c64.charAt(i < 0 ? -i : i)\r\n    x = b ? x / 64n : Math.floor(x / 64)\r\n  }\r\n  return r\r\n}\r\n\r\nfunction writeUInt32LE (u8, value, offset) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  u8[offset + 3] = (value >>> 24)\r\n  u8[offset + 2] = (value >>> 16)\r\n  u8[offset + 1] = (value >>> 8)\r\n  u8[offset] = (value & 0xff)\r\n  return offset + 4\r\n}\r\n\r\nconst max32 = BigInt(2 ** 32)\r\nfunction bigToU8 (n) {\r\n  if (typeof n === 'number') n = BigInt(n)\r\n  if (n < 0) n = -n\r\n  const buf = new Uint8Array(8)\r\n  writeUInt32LE(buf, Number(n / max32), 4)\r\n  writeUInt32LE(buf, Number(n % max32), 0)\r\n  return buf\r\n}\r\n\r\nfunction readUInt32LE (u8, offset) {\r\n  offset = offset >>> 0\r\n  return ((u8[offset]) |\r\n      (u8[offset + 1] << 8) |\r\n      (u8[offset + 2] << 16)) +\r\n      (u8[offset + 3] * 0x1000000)\r\n}\r\n\r\nconst BI_MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\r\nfunction u8ToBig (u8, number = false) {\r\n  const fort = BigInt(readUInt32LE(u8, 4))\r\n  const faible = BigInt(readUInt32LE(u8, 0))\r\n  const r = (fort * max32) + faible\r\n  return number && r < BI_MAX_SAFE_INTEGER ? Number(r) : r\r\n}\r\n\r\nfunction u8ToInt (u8) {\r\n  if (!u8 || !u8.length || u8.length > 8) return 0\r\n  let r = 0n\r\n  for (let i = u8.length - 1; i > 0; i--) {\r\n    r += BigInt(u8[i]) * (p2b[i - 1] + 1n)\r\n  }\r\n  r += BigInt(u8[0])\r\n  return r > BI_MAX_SAFE_INTEGER ? r : Number(r)\r\n}\r\n\r\nconst p2 = [255, (256 ** 2) - 1, (256 ** 3) - 1, (256 ** 4) - 1, (256 ** 5) - 1, (256 ** 6) - 1, (256 ** 7) - 1]\r\nconst p2b = [255n, (256n ** 2n) - 1n, (256n ** 3n) - 1n, (256n ** 4n) - 1n, (256n ** 5n) - 1n, (256n ** 6n) - 1n, (256n ** 7n) - 1n]\r\nfunction intToU8 (n) {\r\n  const bi = typeof n === 'bigint'\r\n  if (n < 0) n = -n\r\n  const p2x = bi ? p2b : p2\r\n  let l = 8\r\n  for (let i = 6; i >= 0; i--, l--) if (n > p2x[i]) break\r\n  const u8 = new Uint8Array(l)\r\n  for (let i = 0; i < 8; i++) {\r\n    u8[i] = bi ? Number(n % 256n) : n % 256\r\n    n = bi ? (n / 256n) : Math.floor(n / 256)\r\n  }\r\n  return u8\r\n}\r\n\r\nfunction sidToId (id) {\r\n  return u8ToInt(b64ToU8(id, true)) // b64 -> buffer\r\n}\r\n\r\nfunction idToSid (id) { // to string (b64)\r\n  if (typeof id === 'string') return id // déjà en B64\r\n  if (typeof id === 'number') return u8ToB64(intToU8(id), true) // int -> u8 -> b64\r\n  return u8ToB64(id, true) // u8 -> b64\r\n}\r\n\r\nasync function test1 () {\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  console.log(int2base64(12345678))\r\n  console.log(int2base64(12345678n))\r\n  console.log(hash(xx, false, false))\r\n  console.log(hash(xx, false, true))\r\n  console.log(hash(xx, true, false))\r\n  console.log(hash(xx, true, true))\r\n  let z = hash(xx, false)\r\n  console.log(z)\r\n  const b1 = bigToU8(z)\r\n  console.log(u8ToB64(b1, true))\r\n  console.log(u8ToBig(b1))\r\n  z = hash(xx, true)\r\n  console.log(z)\r\n  const b2 = bigToU8(z)\r\n  console.log(u8ToB64(b2, true))\r\n  console.log(u8ToBig(b2, true))\r\n  console.log(u8ToBig(b2))\r\n  console.log(b1.length + ' - ' + b2.length)\r\n\r\n  const m7 = (2n ** 64n) - 1n\r\n  const m5 = p2[4] + 10\r\n  const m5b = p2b[4] + 10n\r\n  const m1 = 10\r\n  let u7, v7, i7, j7\r\n  const t1 = new Date().getTime()\r\n  for (let i = 0; i < 1000; i++) {\r\n    u7 = intToU8(m7)\r\n    i7 = u8ToInt(u7)\r\n  }\r\n  const t2 = new Date().getTime()\r\n  console.log((t2 - t1) + 'ms')\r\n  for (let i = 0; i < 1000; i++) {\r\n    v7 = bigToU8(m7)\r\n    j7 = u8ToBig(v7)\r\n  }\r\n  const t3 = new Date().getTime()\r\n  console.log((t3 - t2) + 'ms')\r\n  console.log('u7 ' + hashBin(u7))\r\n  console.log('v7 ' + hashBin(v7))\r\n\r\n  const u5 = intToU8(m5)\r\n  const v5 = bigToU8(m5b)\r\n  const i5 = u8ToInt(u5)\r\n  const j5 = u8ToBig(v5)\r\n  console.log('u5 ' + hashBin(u5))\r\n  console.log('v5 ' + hashBin(v5))\r\n\r\n  const u1 = intToU8(m1)\r\n  const v1 = bigToU8(10n)\r\n  const i1 = u8ToInt(u1)\r\n  const j1 = u8ToBig(v1)\r\n  console.log('u1 ' + hashBin(u1))\r\n  console.log('v1 ' + hashBin(v1))\r\n\r\n  console.log(m7 + ' ' + u7.toString('hex') + ' ' + v7.toString('hex') + ' ' + i7 + ' ' + j7)\r\n  console.log(m5 + ' ' + u5.toString('hex') + ' ' + v5.toString('hex') + ' ' + i5 + ' ' + j5)\r\n  console.log(m1 + ' ' + u1.toString('hex') + ' ' + v1.toString('hex') + ' ' + i1 + ' ' + j1)\r\n}\r\n\r\nasync function test2 () {\r\n  const enc = new TextEncoder()\r\n  const dec = new TextDecoder()\r\n\r\n  let cle = 'toto est beau'\r\n  const clebin2 = await crypt.pbkfd(cle)\r\n  const s1 = u8ToB64(clebin2, true)\r\n  let u8 = b64ToU8(s1)\r\n  const s2 = u8ToB64(clebin2, false)\r\n  console.log(s1)\r\n  console.log(s2)\r\n  u8 = b64ToU8(s1)\r\n  const s3 = u8ToB64(u8, false)\r\n  console.log(s3)\r\n\r\n  cle = enc.encode('toto est beau')\r\n  const clebin = crypt.sha256(cle)\r\n  console.log(u8ToB64(clebin, true))\r\n\r\n  const sha2 = crypt.sha256(cle)\r\n  console.log(u8ToB64(sha2, true))\r\n\r\n  let x = crypt.random(16)\r\n  console.log(u8ToB64(x, true))\r\n  x = crypt.random(6)\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  x = enc.encode(xx)\r\n  const e1 = await crypt.crypter(clebin, x)\r\n  console.log(e1.toString('hex'))\r\n  const d1 = await crypt.decrypter(clebin, e1)\r\n  console.log(dec.decode(d1))\r\n  const y = crypt.random(1)\r\n  const n = Number(y[0])\r\n  const e2 = await crypt.crypter(clebin, x, n)\r\n  console.log(e2.toString('hex'))\r\n  const d2 = await crypt.decrypter(clebin, e2)\r\n  console.log(dec.decode(d2))\r\n  const e3 = await crypt.crypter(clebin, x, n)\r\n  console.log(e3.toString('hex'))\r\n  const d3 = await crypt.decrypter(clebin, e3)\r\n  console.log(dec.decode(d3))\r\n\r\n  const kp = await crypt.genKeyPair()\r\n  const encRSA2 = await crypt.crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA2 : ' + u8ToB64(encRSA2))\r\n  const decRSA2 = await crypt.decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA2))\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/crypto.mjs?");

/***/ }),

/***/ "./src/m1.mjs":
/*!********************!*\
  !*** ./src/m1.mjs ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"m1fonctions\": () => (/* binding */ m1fonctions)\n/* harmony export */ });\n/* harmony import */ var _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crypto.mjs */ \"./src/crypto.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.mjs */ \"./src/util.mjs\");\n/* harmony import */ var _session_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./session.mjs */ \"./src/session.mjs\");\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n/* harmony import */ var _storage_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage.mjs */ \"./src/storage.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst m1fonctions = { }\r\nconst MO = 1024 * 1024\r\nconst VERSIONS = 1\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nconst dev = \"development\" === 'development'\r\nconst nbVersions = 100\r\nconst defautVersions = new Array(nbVersions)\r\nfor (let i = 0; i < nbVersions; i++) { defautVersions[i] = 0 }\r\n\r\nconst valueTypes = {\r\n  0: { type: 'json', defaut: '{}' },\r\n  1: { defaut: defautVersions }\r\n}\r\n\r\n/*\r\nInitialisation du module APRES que le serveur ait été créé et soit opérationnel\r\nRafraîchissement périodique en cache (si demandé et seulement pour la production) de la liste des aricles à peser\r\nafin que les balances aient plus rapidement la réponse en cas de changement dans Odoo\r\n*/\r\nfunction atStart(/* cfg */) {\r\n  console.log('m1 start')\r\n}\r\nm1fonctions.atStart = atStart\r\n\r\n/***************************************************************\r\nAppel de l'opération\r\n    cfg : configuration relative au code de l'organisation    \r\n    args : objet des arguments\r\nRetourne un objet result :node -version\r\n\r\n    result.type : type mime\r\n    result.bytes : si le résultat est du binaire\r\nPour un POST :\r\n    OK : result : objet résultat à sérialiser - HTTP status 200\r\n\r\nException : \r\n    AppExc : AppExc sérialisé en JSON\r\n        code F_SRV - erreur fonctionnelle à retourner par l'application\r\n            HTTP status 400\r\n        code X_SRV - erreur fonctionnelle à émettre en exception à l'application\r\n            HTTP status 401                   \r\n    Non transformée en AppExc : Création d'un AppExc avec E_SRV sérialisé en JSON\r\n        HTTP status 402\r\n*****************************************************************/\r\n\r\nfunction checkSession (sessionId) {\r\n  const session = (0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.getSession)(sessionId)\r\n  if (!session) throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.E_WS, 'Session interrompue. Se déconnecter et tenter de se reconnecter')\r\n  return session\r\n}\r\n\r\nasync function echo (cfg, args, isGet) {\r\n  if (args.to) {\r\n    await (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.sleep)(args.to * 1000)\r\n  }\r\n  if (!args) args = { a: 1, b: 'toto' }\r\n  args.org = cfg.code || 'org'\r\n  return !isGet ? args : { type:'text/plain', bytes:Buffer.from(JSON.stringify(args), 'utf8') }\r\n}\r\nm1fonctions.echo = echo\r\n\r\nasync function erreur (cfg, args) {\r\n  if (args.to) {\r\n    await (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.sleep)(args.to * 1000)\r\n  }\r\n  throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(args.code, args.message)\r\n}\r\nm1fonctions.erreur = erreur\r\n\r\nasync function pingdb (cfg) {\r\n  stmt(cfg, selvalues).get({ id: 1 })\r\n  return { dhc: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n}\r\nm1fonctions.pingdb = pingdb\r\n\r\n/******************************************/\r\nconst cachestmt = { }\r\n\r\nfunction stmt (cfg, sql) {\r\n  let c = cachestmt[cfg.code]\r\n  if (!c) { c = {}; cachestmt[cfg.code] = c }\r\n  if (!c[sql])\r\n    try {\r\n      c[sql] = cfg.db.prepare(sql)\r\n    } catch (e) {\r\n      console.log(e.toString())\r\n    }\r\n  return c[sql]\r\n}\r\n\r\n/******************************************/\r\nconst selvalues = 'SELECT v FROM versions WHERE id = @id'\r\nconst insvalues = 'INSERT INTO versions (id, v) VALUES (@id, @v)'\r\nconst updvalues = 'UPDATE versions SET v = @v WHERE id = @id'\r\n\r\nconst cacheValues = { }\r\n\r\nfunction getValue (cfg, n) {\r\n  let cache = cacheValues[cfg.code]\r\n  if (!cache) {\r\n    cache = {}\r\n    cacheValues[cfg.code] = cache\r\n  }\r\n  if (cache[n]) return cache[n]\r\n  const t = valueTypes[n]\r\n  let value\r\n  const res = stmt(cfg, selvalues).get({ id: n })\r\n  let bin = res ? res.v : null\r\n  if (bin) {\r\n    value = t.type === 'json' ? JSON.parse(Buffer.from(bin).toString()) : (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(bin)\r\n  } else {\r\n    value = t.defaut\r\n    bin = t.type === 'json' ? Buffer.from(value) : (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(value)\r\n    stmt(cfg, insvalues).run({ id: n, v: bin })\r\n  }\r\n  cache[n] = value\r\n  return value\r\n}\r\n\r\nfunction setValue (cfg, n) {\r\n  const t = valueTypes[n]\r\n  const value = cacheValues[cfg.code][n]\r\n  const bin = t.type === 'json' ? Buffer.from(value) : (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(value)\r\n  stmt(cfg, updvalues).run({ id: n, v: bin })\r\n}\r\n\r\n/******************************************/\r\nfunction newItem (table, row) {\r\n  const item = { table: table }\r\n  if (row.id) item.id = row.id\r\n  item.serial = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.serialize('row' + table, row)\r\n  return item\r\n}\r\n\r\n/******************************************/\r\nconst inscompte = 'INSERT INTO compte (id, v, dds, dpbh, pcbh, kx, mack, vsh) VALUES (@id, @v, @dds, @dpbh, @pcbh, @kx, @mack, @vsh)'\r\nconst insprefs = 'INSERT INTO prefs (id, v, mapk, vsh) VALUES (@id, @v, @mapk, @vsh)'\r\nconst insavatar = 'INSERT INTO avatar (id, v, st, vcv, dds, cva, vsh) VALUES (@id, @v, @st, @vcv, @dds, @cva, @vsh)'\r\nconst insavrsa = 'INSERT INTO avrsa (id, clepub, vsh) VALUES (@id, @clepub, @vsh)'\r\nconst selavgrvqid = 'SELECT * FROM avgrvq WHERE id = @id'\r\nconst insavgrvq = 'INSERT INTO avgrvq (id, q1, q2, qm1, qm2, v1, v2, vm1, vm2, vsh) VALUES (@id, @q1, @q2, @qm1, @qm2, @v1, @v2, @vm1, @vm2, @vsh)'\r\nconst updavgrvq = 'UPDATE avgrvq SET q1 = @q1, q2 = @q2, qm1 = @qm1, qm2 = @qm2, v1 = @v1, v2 = @v2, vm1 = @vm1, vm2 = @vm2 WHERE id = @id'\r\nconst selcomptedpbh = 'SELECT * FROM compte WHERE dpbh = @dpbh'\r\nconst selprefsid = 'SELECT * FROM prefs WHERE id = @id'\r\nconst selavatarid = 'SELECT * FROM avatar WHERE id = @id'\r\nconst selsecretidns = 'SELECT * FROM secret WHERE id = @id AND ns = @ns'\r\n\r\nfunction idx (id) {\r\n  return (id % (nbVersions - 1)) + 1\r\n}\r\n\r\n/* Creation de compte sans parrain ****************************************\r\n- sessionId, mdp64, q1, q2, qm1, qm2, clePub rowCompte, rowAvatar, rowPrefs\r\nRetour :\r\n- sessionId\r\n- dh\r\n*/\r\nfunction creationCompte (cfg, args) {\r\n  checkSession(args.sessionId)  \r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  if (cfg.cle !== args.mdp64) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Mot de passe de l\\'organisation non reconnu. Pour créer un compte privilégié, le mot de passe de l\\'organisation est requis')\r\n  }\r\n  const session = checkSession(args.sessionId)\r\n  const compte = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowcompte', args.rowCompte)\r\n  const avatar = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowavatar', args.rowAvatar)\r\n  const prefs = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowprefs', args.rowPrefs)\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  let j = idx(compte.id)\r\n  versions[j]++\r\n  compte.v = versions[j]\r\n  prefs.v = versions[j]\r\n\r\n  j = idx(avatar.id)\r\n  versions[j]++\r\n  avatar.v = versions[j]\r\n  setValue(cfg, VERSIONS)\r\n\r\n  compte.dds = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsc(0)\r\n  avatar.dds = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsag(0)\r\n  const avrsa = { id: avatar.id, clepub: args.clePub, vsh: 0 }\r\n  const avgrvq = { id: avatar.id, q1: args.q1*MO, q2: args.q2*MO, qm1: args.qm1*MO, qm2:args.qm2*MO, v1: 0, v2:0, vm1:0, vm2: 0, vsh: 0 }\r\n\r\n  cfg.db.transaction(creationCompteTr)(cfg, session, compte, avatar, prefs, avrsa, avgrvq)\r\n\r\n  result.rowItems = [ newItem('compte', compte), newItem('avatar', avatar), newItem('prefs', prefs) ]    \r\n  return result\r\n}\r\nm1fonctions.creationCompte = creationCompte\r\n\r\nfunction creationCompteTr (cfg, session, compte, avatar, prefs, avrsa, avgrvq) {\r\n  const c = stmt(cfg, selcomptedpbh).get({ dpbh: compte.dpbh })\r\n  if (c) {\r\n    if (c.pcbh === compte.pcbh) {\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Phrase secrète probablement déjà utilisée. Vérifier que le compte n\\'existe pas déjà en essayant de s\\'y connecter avec la phrase secrète')\r\n    } else {\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Une phrase secrète semblable est déjà utilisée. Changer a minima la première ligne de la phrase secrète pour ce nouveau compte')\r\n    }\r\n  }\r\n  stmt(cfg, inscompte).run(compte)\r\n  stmt(cfg, insavatar).run(avatar)\r\n  stmt(cfg, insprefs).run(prefs)\r\n  stmt(cfg, insavrsa).run(avrsa)\r\n  stmt(cfg, insavgrvq).run(avgrvq)\r\n  session.compteId = compte.id\r\n  session.plusAvatars([avatar.id])\r\n}\r\n\r\n/***************************************\r\nEnregistrement d'une préférence d'un compte :\r\nArgs : \r\n- sessionId\r\n- id: du compte\r\n- code : code de la préférence\r\n- datak : données de la préférence crypté par la clé K\r\nRetour :\r\n- sessionId\r\n- dh\r\nException : compte inexistant\r\n*/\r\nconst updprefs = 'UPDATE prefs SET v = @v, mapk = @mapk WHERE id = @id'\r\n\r\nfunction prefCompte (cfg, args) {\r\n  checkSession(args.sessionId) \r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  const v = versions[j]\r\n\r\n  const rowItems = []\r\n\r\n  cfg.db.transaction(prefCompteTr)(cfg, args.id, v, args.code, args.datak, rowItems)\r\n\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return { sessionId: args.sessionId, dh: dh }\r\n}\r\nm1fonctions.prefCompte = prefCompte\r\n\r\nfunction prefCompteTr (cfg, id, v, code, datak, rowItems) {\r\n  const p = stmt(cfg, selprefsid).get({ id: id })\r\n  if (!p) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Compte inexistant. Bug probable.')\r\n  }\r\n  const x = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(p.mapk)\r\n  x[code] = datak\r\n  p.mapk = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(x)\r\n  p.v = v\r\n  stmt(cfg, updprefs).run( { mapk: p.mapk, v, id })\r\n  rowItems.push(newItem('prefs', p))\r\n}\r\n\r\n/***************************************\r\nEnregistrement de la CV d'un avatar :\r\nArgs : \r\n- sessionId\r\n- id: de l'avatar\r\n- phinfo : [ph, info] crypté par la clé de l'avatar et sérialisé]\r\nRetour :\r\n- sessionId\r\n- dh\r\nException : avatar inexistant\r\n*/\r\nconst updcvavatar = 'UPDATE avatar SET v = @v, vcv = @vcv, cva = @cva WHERE id = @id'\r\n\r\nfunction cvAvatar (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  const v = versions[j]\r\n\r\n  const rowItems = []\r\n\r\n  cfg.db.transaction(cvAvatarTr)(cfg, args.id, v, args.phinfo, rowItems)\r\n\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return { sessionId: args.sessionId, dh: dh }\r\n}\r\nm1fonctions.cvAvatar = cvAvatar\r\n\r\nfunction cvAvatarTr (cfg, id, v, cva, rowItems) {\r\n  const a = stmt(cfg, selavatarid).get({ id: id })\r\n  if (!a) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Avatar inexistant. Bug probable.')\r\n  }\r\n  a.cva = cva\r\n  a.v = v\r\n  a.vcv = v\r\n  stmt(cfg, updcvavatar).run( { cva, vcv: v, v, id })\r\n  rowItems.push(newItem('avatar', a))\r\n  // cols: ['id', 'vcv', 'st', 'cva']\r\n  rowItems.push(newItem('cv', { id: id, vcv: v, st: a.st, cva: cva }))\r\n}\r\n\r\n/******************************************\r\nDétermine si les hash de la phrase secrète en argument correspond à un compte.\r\nargs = { dpbh, pcbh }\r\nRetour = compte, prefs\r\n*/\r\nasync function connexionCompte (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const c = stmt(cfg, selcomptedpbh).get({ dpbh: args.dpbh })\r\n  if (!c || (c.pcbh !== args.pcbh)) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Compte non authentifié : aucun compte n\\'est déclaré avec cette phrase secrète')\r\n  }\r\n  const p = stmt(cfg, selprefsid).get({ id: c.id })\r\n  if (!p) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Compte corrompu : données de préférence absentes')\r\n  }\r\n  result.rowItems = [ newItem('compte', c), newItem('prefs', p) ]\r\n  return result\r\n}\r\nm1fonctions.connexionCompte = connexionCompte\r\n\r\n/**************************************** */\r\nconst selavatar = 'SELECT * FROM avatar WHERE id = @id AND v > @v'\r\nconst selsecret = 'SELECT * FROM secret WHERE id = @id AND v > @v'\r\nconst selcontact = 'SELECT * FROM contact WHERE id = @id AND v > @v'\r\nconst selcontactIdIc = 'SELECT * FROM contact WHERE id = @id AND ic = @ic'\r\nconst selrencontre = 'SELECT * FROM rencontre WHERE id = @id AND v > @v'\r\nconst selparrain = 'SELECT * FROM parrain WHERE id = @id AND v > @v'\r\nconst selgroupe = 'SELECT * FROM groupe WHERE id = @id AND v > @v'\r\nconst selmembre = 'SELECT * FROM membre WHERE id = @id AND v > @v'\r\n\r\n/*****************************************\r\nChargement des avatars d'un compte\r\n- sessionId\r\n- idsVers : map de clé:id de l'avatar, valeur: version détenue en session\r\n*/\r\nasync function chargerAv (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const rowItems = []\r\n  for(const id in args.idsVers) {\r\n    const rows = stmt(cfg, selavatar).all({ id, v: args.idsVers[id] })\r\n    rows.forEach((row) => {\r\n      rowItems.push(newItem('avatar', row))\r\n    })\r\n  }\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.chargerAv = chargerAv\r\n\r\n/*****************************************\r\nChargement des invitGr des avatars d'un compte\r\n- sessionId, ids (array des ids des avatars)\r\n*/\r\nconst selinvitgr = 'SELECT * FROM invitgr WHERE id = @id'\r\n\r\nasync function chargerInvitGr (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)(), rowItems: [] }\r\n  for (let i = 0; i < args.ids.length; i++) {\r\n    const rows = stmt(cfg, selinvitgr).all({ id: args.ids[i] })\r\n    rows.forEach((row) => {\r\n      result.rowItems.push(newItem('invitgr', row))\r\n    })\r\n  }\r\n  return result\r\n}\r\nm1fonctions.chargerInvitGr = chargerInvitGr\r\n\r\n/*****************************************\r\nCréation d'un invitGr\r\n- sessionId, id, ni, datap\r\n*/\r\nconst insinvitgr = 'INSERT INTO invitgr (id, ni, datap) VALUES (@id, @ni, @datap)'\r\n\r\nasync function creerInvitGr (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const row = { id: args.id, ni: args.id, nomcp: args.datap }\r\n  const rowItems = [row]\r\n  cfg.db.transaction(creerInvitGrTr)(cfg, row)\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: result.dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return result\r\n}\r\nm1fonctions.creerInvitGr = creerInvitGr\r\n\r\nfunction creerInvitGrTr (cfg, row) {\r\n  stmt(cfg, insinvitgr).run(row)\r\n}\r\n\r\n/*****************************************\r\nChargement des rows d'un avatar \r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'avgr', type: 'long' },\r\n    { name: 'lv', type: arrayIntType } 7 compteurs pour les versions des 7 tables\r\n*/\r\nasync function syncAv (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const rowItems = []\r\n  const id = args.avgr\r\n  let rows\r\n  const lva = args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.AVATAR]\r\n  if (lva !== -1) {\r\n    rows = stmt(cfg, selavatar).all({ id, v: lva })\r\n    rows.forEach((row) => {\r\n      rowItems.push(newItem('avatar', row))\r\n    })\r\n  }\r\n  rows = stmt(cfg, selcontact).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.CONTACT] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('contact', row))\r\n  })\r\n  rows = stmt(cfg, selrencontre).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.RENCONTRE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('rencontre', row))\r\n  })\r\n  rows = stmt(cfg, selparrain).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.PARRAIN] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('parrain', row))\r\n  })\r\n  rows = stmt(cfg, selsecret).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.SECRET] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('secret', row))\r\n  })\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.syncAv = syncAv\r\n\r\n/*****************************************/\r\nasync function syncGr (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const rowItems = []\r\n  const id = args.avgr\r\n  let rows = stmt(cfg, selgroupe).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.GROUPE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('groupe', row))\r\n  })\r\n  rows = stmt(cfg, selmembre).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.MEMBRE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('membre', row))\r\n  })\r\n  rows = stmt(cfg, selsecret).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.SECRET] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('secret', row))\r\n  })\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.syncGr = syncGr\r\n\r\n/******************************************\r\nAbonnement de la session aux compte et listes d'avatars et de groupes et signatures\r\n- sessionId\r\n- idc : id du compte\r\n- lav : array des ids des avatars\r\n- lgr : array des ids des groupes\r\n- sign : true s'il faut signer\r\n*/\r\nasync function syncAbo (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const session = checkSession(args.sessionId)\r\n\r\n  // Abonnements\r\n  session.compteId = args.idc\r\n  session.avatarsIds = new Set(args.lav)\r\n  session.groupesIds = new Set(args.lgr)\r\n\r\n  // Signatures\r\n  if (args.sign) {\r\n    cfg.db.transaction(signaturesTr)(cfg, args.idc, args.lav, args.lgr)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nconst updddsc = 'UPDATE compte SET dds = @dds WHERE id = @id'\r\nconst updddsa= 'UPDATE avatar SET dds = @dds WHERE id = @id'\r\nconst updddsg = 'UPDATE groupe SET dds = @dds WHERE id = @id'\r\nconst ddsc = 'SELECT dds FROM compte WHERE id = @id'\r\nconst ddsa = 'SELECT dds FROM avatar WHERE id = @id'\r\nconst ddsg = 'SELECT dds FROM groupe WHERE id = @id'\r\n\r\nfunction signaturesTr (cfg, idc, lav, lgr) {\r\n  const a = stmt(cfg, ddsc).get({ id: idc })\r\n  const n = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsc(a)\r\n  if (a > n) stmt(cfg, updddsc).run({ id: idc, dds:a })\r\n\r\n  lav.forEach((id) => {\r\n    const a = stmt(cfg, ddsa).get({ id: id })\r\n    const n = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsag(a)\r\n    if (a > n) stmt(cfg, updddsa).run({ id: id, dds: a })\r\n  })\r\n\r\n  lgr.forEach((id) => {\r\n    const a = stmt(cfg, ddsg).get({ id: id })\r\n    const n = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsag(a)\r\n    if (a > n) stmt(cfg, updddsg).run({ id: id, dds: a })\r\n  })\r\n}\r\nm1fonctions.syncAbo = syncAbo\r\n\r\n/******************************************\r\nChargement des CVs :\r\n- celles de lcvmaj si changées après vcv\r\n- celles de lcvchargt sans filtre de version\r\nAbonnement à l'union des deux listes\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'vcv', type: 'int' },\r\n    { name: 'lcvmaj', type: arrayIntType },\r\n    { name: 'lcvchargt', type: arrayIntType }\r\n*/\r\nconst selcv1 = 'SELECT id, vcv, st, cva FROM avatar WHERE vcv > @vcv AND id IN ('\r\nconst selcv2 = 'SELECT id, vcv, st, cva FROM avatar WHERE id IN ('\r\n\r\nasync function chargtCVs (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)() }\r\n  const session = checkSession(args.sessionId)\r\n  session.cvsIds = new Set(args.lcvmaj.concat(args.lcvchargt))\r\n  const rowItems = []\r\n\r\n  if (args.lcvmaj.length) {\r\n    const lst = []\r\n    args.lcvmaj.forEach((id) => { lst.push(id) })\r\n    // lst.push(3382219599812300) pour tester la syntaxe IN\r\n    const st = cfg.db.prepare(selcv1 + lst.join(',') + ')')\r\n    const rows = st.all({ vcv: args.vcv })\r\n    for (const row of rows) {\r\n      rowItems.push(newItem('cv', row))\r\n    }\r\n  }\r\n  \r\n  if (args.lcvchargt.length) {\r\n    const lst = []\r\n    args.lcvchargt.forEach((id) => { lst.push(id) })\r\n    const st = cfg.db.prepare(selcv2 + lst.join(',') + ')')\r\n    const rows = st.all()\r\n    for (const row of rows) {\r\n      rowItems.push(newItem('cv', row))\r\n    }\r\n  }\r\n\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.chargtCVs = chargtCVs\r\n\r\n/*****************************************\r\ngetcv : retourne la CV d'un avatar\r\nargs : \r\n-sessionId\r\n-sid de l'avatar\r\n*/\r\nconst bytes0 = new Uint8Array(0)\r\nconst selcv = 'SELECT id, st, vcv, cva FROM avatar WHERE id = @id'\r\nasync function getcv (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  try {\r\n    const c = stmt(cfg, selcv).get({ id: _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.sidToId(args.sid) })\r\n    if (!c) return { bytes0 }\r\n    const buf = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.serialize('rowcv', c)\r\n    return { bytes: buf }\r\n  } catch (e) {\r\n    console.log(e)\r\n    return { bytes: bytes0 }\r\n  }\r\n}\r\nm1fonctions.getcv = getcv\r\n\r\n/*****************************************\r\ngetclepub : retourne la clé publique d'un avatar\r\nargs : \r\n-sessionId\r\n-sid de l'avatar\r\n*/\r\nconst selavrsapub = 'SELECT clepub FROM avrsa WHERE id = @id'\r\nasync function getclepub (cfg, args) {\r\n  // checkSession(args.sessionId)\r\n  try {\r\n    const c = stmt(cfg, selavrsapub).get({ id: _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.sidToId(args.sid) })\r\n    if (!c) return { bytes0 }\r\n    return { bytes: c.clepub }\r\n  } catch (e) {\r\n    console.log(e)\r\n    return { bytes: bytes0 }\r\n  }\r\n}\r\nm1fonctions.getclepub = getclepub\r\n\r\n/***************************************\r\nNouveau secret personnel\r\nArgs : \r\n- sessionId\r\n- ts, id, ns, ic, st, ora, v1, mcg, mc, im, txts, dups, refs, id2, ns2, ic2, dups2\r\nRetour :\r\n- sessionId\r\n- dh\r\nException : dépassement des quotas \r\n*/\r\nconst inssecret = 'INSERT INTO secret (id, ns, ic, v, st, ora, v1, v2, mc, txts, mpjs, dups, refs, vsh) ' +\r\n  'VALUES (@id, @ns, @ic, @v, @st, @ora, @v1, @v2, @mc, @txts, @mpjs, @dups, @refs, @vsh)'\r\n\r\nasync function nouveauSecret (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  const v = versions[j]\r\n  let vb\r\n  if (args.ts === 1) {\r\n    const j2 = idx(args.id2)\r\n    versions[j2]++\r\n    setValue(cfg, VERSIONS)\r\n    vb = versions[j2]\r\n  }\r\n\r\n  let mc\r\n  if (args.ts === 2) {\r\n    const x = { }\r\n    x[0] = args.mcg\r\n    x[args.im] = args.mc\r\n    mc = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(x)\r\n  } else {\r\n    mc = args.mc\r\n  }\r\n\r\n  const secret = { \r\n    id: args.id,\r\n    ns: args.ns,\r\n    ic: args.ic,\r\n    v: v,\r\n    st: args.st,\r\n    ora: args.ora,\r\n    v1: args.v1,\r\n    v2: 0,\r\n    mc: mc,\r\n    txts: args.txts,\r\n    mpjs: null,\r\n    dups: args.ts === 1 ? args.dups : null,\r\n    refs: args.refs || null,\r\n    vsh: 0\r\n  }\r\n  \r\n  let secret2\r\n  if (args.ts ===1) secret2 = { \r\n    id: args.id2,\r\n    ns: args.ns2,\r\n    ic: args.ic2,\r\n    v: vb,\r\n    st: args.st,\r\n    ora: args.ora,\r\n    v1: args.v1,\r\n    v2: 0,\r\n    mc: null,\r\n    txts: args.txts,\r\n    mpjs: null,\r\n    dups: args.dups2,\r\n    refs: args.refs,\r\n    vsh: 0\r\n  }\r\n\r\n  cfg.db.transaction(nouveauSecretTr)(cfg, secret, secret2 )\r\n\r\n  const rowItems = []\r\n  rowItems.push(newItem('secret', secret))\r\n  if (args.ts ===1) rowItems.push(newItem('secret', secret2))\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return { sessionId: args.sessionId, dh: dh }\r\n}\r\nm1fonctions.nouveauSecret = nouveauSecret\r\n\r\nfunction nouveauSecretTr (cfg, secret, secret2) {\r\n  const a = stmt(cfg, selavgrvqid).get({ id: secret.id })\r\n  if (a) {\r\n    if (secret.st === 99999) {\r\n      a.v1 = a.v1 + secret.v1\r\n    } else {\r\n      a.vm1 = a.vm1 + secret.v1\r\n    }\r\n  }\r\n  if (!a || a.v1 > a.q1 || a.vm1 > a.qm1) {\r\n    // console.log('Quotas d\\'espace insuffisants.')\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Quotas d\\'espace insuffisants.')\r\n  }\r\n  stmt(cfg, updavgrvq).run(a)\r\n  stmt(cfg, inssecret).run(secret)\r\n\r\n  if (secret2) {\r\n    const a = stmt(cfg, selavgrvqid).get({ id: secret2.id })\r\n    if (a) {\r\n      if (secret.st === 99999) {\r\n        a.v1 = a.v1 + secret.v1\r\n      } else {\r\n        a.vm1 = a.vm1 + secret.v1\r\n      }\r\n    }\r\n    stmt(cfg, updavgrvq).run(a)\r\n    stmt(cfg, inssecret).run(secret2)\r\n  }\r\n}\r\n\r\n/***************************************\r\nMAJ secret\r\nArgs : \r\n- sessionId\r\n- ts, id, ns, v1, mc, im, mcg, txts, ora, temp, id2, ns2\r\ntemp : null: inchangé, 99999: devient permanent, 780: (re)devient temporaire\r\nora : null: inchangé, xxxp (im d'exclusivité, 0/1 libre / protégé)\r\ntxts: null: inchangé\r\nmcg: null: inchangé (im sert à mettre à jour les motsclés)\r\n\r\nRetour :\r\n- sessionId\r\n- dh\r\nException : dépassement des quotas \r\n*/\r\nconst upd1secret = 'UPDATE secret SET v = @v, st = @st, ora = @ora, v1 = @v1, txts = @txts, mc = @mc WHERE id = @id AND ns = @ns'\r\n\r\nasync function maj1Secret (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  args.v = versions[j]\r\n\r\n  if (args.ts ===1) {\r\n    const j2 = idx(args.id2)\r\n    versions[j2]++\r\n    setValue(cfg, VERSIONS)\r\n    args.vb = versions[j2]\r\n  }\r\n\r\n  const rowItems = []\r\n\r\n  cfg.db.transaction(maj1SecretTr)(cfg, args, rowItems)\r\n\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return { sessionId: args.sessionId, dh: dh }\r\n}\r\nm1fonctions.maj1Secret = maj1Secret\r\n\r\nfunction maj1SecretTr (cfg, args, rowItems) {\r\n\r\n  const secret = stmt(cfg, selsecretidns).get({ id: args.id, ns: args.ns }) \r\n  if (!secret) {\r\n    // console.log('Secret inconnu.')\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Secret inexistant.')\r\n  }\r\n\r\n  let deltav1 = 0, deltavm1 = 0, deltav2 = 0, deltavm2 = 0\r\n  const pv1 = args.v1 === null ? secret.v1 : args.v1\r\n  if (args.temp === null) {\r\n    // pas de changement perm / temp\r\n    if (secret.st === 99999) {\r\n      deltav1 = pv1 - secret.v1 // il était permanent\r\n    } else {\r\n      deltavm1 = pv1 - secret.v1\r\n    }\r\n  } else if (args.temp === 99999) { // devient permanent\r\n    deltav1 = pv1 // le volume permanent augmente du nouveau volume\r\n    deltavm1 = -secret.v1 // le volume temporaire diminue de l'ancien volume\r\n    deltav2 = secret.v2\r\n    deltavm2 = -secret.v2\r\n    secret.st = 99999\r\n  } else { // (args.temp > 0 && args.temp < 99999) - (re)devient temporaire\r\n    deltav1 = -secret.v1 // le volume permanent diminue de l'ancien volume\r\n    deltavm1 = pv1 // le volume temporaire augmente du nouveau volume\r\n    deltav2 = -secret.v2\r\n    deltavm2 = secret.v2\r\n    secret.st = args.temp\r\n  }\r\n  \r\n  secret.v = args.v\r\n  secret.v1 = pv1\r\n  if (args.txts !== null) secret.txts = args.txts // sinon texte inchangé par convention\r\n  if (args.ts !== 2 && args.mc !== null) secret.mc = args.mc\r\n  if (args.ts === 2 && (args.mc !== null || args.mcg !== null)) {\r\n    const mc = secret.mc ? (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(secret.mc) : { }\r\n    if (args.mc !== null) {\r\n      if (args.mc.length) {\r\n        mc[args.im] = args.mc\r\n      } else {\r\n        delete mc[args.im]\r\n      }\r\n    }\r\n    if (args.mcg !== null) {\r\n      if (args.mc.length) {\r\n        mc[0] = args.mcg\r\n      } else {\r\n        delete mc[0]\r\n      }\r\n    }\r\n    secret.mc = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(mc)\r\n  }\r\n  if (args.ora !== null) secret.ora = args.ora\r\n\r\n  let secret2\r\n  if (args.ts === 1) {\r\n    // secret2 PEUT avoir été détruit\r\n    secret2 = stmt(cfg, selsecretidns).get({ id: args.id2, ns: args.ns2 }) \r\n    if (secret2) {\r\n      secret2.v = args.vb\r\n      secret2.st = secret.st\r\n      secret2.v1 = secret.v1\r\n      secret2.txts = secret.txts\r\n      secret2.ora = secret.ora\r\n    }\r\n  }\r\n\r\n  if (deltav1 || deltav2 || deltavm1 || deltavm2) {\r\n    const a = stmt(cfg, selavgrvqid).get({ id: args.id })\r\n    if (a) {\r\n      a.v1 = a.v1 + deltav1\r\n      a.vm1 = a.vm1 + deltavm1\r\n      a.v2 = a.v2 + deltav2\r\n      a.vm2 = a.vm2 + deltavm2\r\n    }\r\n    if (!a || a.v1 > a.q1 || a.vm1 > a.qm1 || a.v2 > a.q2 || a.vm2 > a.qm2) {\r\n      console.log('Quotas d\\'espace insuffisants.')\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Quotas d\\'espace insuffisants.')\r\n    }\r\n    stmt(cfg, updavgrvq).run(a)\r\n\r\n    if (secret2) {\r\n      const a = stmt(cfg, selavgrvqid).get({ id: args.id2 })\r\n      if (a) {\r\n        a.v1 = a.v1 + deltav1\r\n        a.vm1 = a.vm1 + deltavm1\r\n        a.v2 = a.v2 + deltav2\r\n        a.vm2 = a.vm2 + deltavm2\r\n        stmt(cfg, updavgrvq).run(a)\r\n      }\r\n    }\r\n  }\r\n\r\n  rowItems.push(newItem('secret', secret))\r\n  stmt(cfg, upd1secret).run(secret)\r\n\r\n  if (secret2) {\r\n    stmt(cfg, upd1secret).run(secret2)\r\n    rowItems.push(newItem('secret', secret2))\r\n  }\r\n}\r\n\r\n/***************************************\r\nPièce jointe d'un secret - Ajout / modification / suppression\r\nArgs : \r\n- sessionId\r\n- { ts, id: s.id, ns: s.ns, cle, idc, buf, lg, id2, ns2 }\r\n- `cle` : hash court en base64 URL de nom.ext\r\n- `idc` : id complète de la pièce jointe (nom.txt/type/dh), cryptée par la clé du secret et en base64 URL.\r\n- buf : contenu binaire crypté.\r\n- lg : taille de la pièce jointe d'origine (non gzippée, non cryptée)\r\n\r\nSuppression : buf et idc sont null\r\n\r\nRetour :\r\n- sessionId\r\n- dh\r\nException : dépassement des quotas \r\n*/\r\nconst upd2secret = 'UPDATE secret SET v = @v, v2 = @v2, mpjs = @mpjs WHERE id = @id AND ns = @ns'\r\n\r\nasync function pjSecret (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  args.v = versions[j]\r\n\r\n  if (args.ts ===1) {\r\n    const j2 = idx(args.id2)\r\n    versions[j2]++\r\n    setValue(cfg, VERSIONS)\r\n    args.vb = versions[j2]\r\n  }\r\n\r\n  const secret = stmt(cfg, selsecretidns).get({ id: args.id, ns: args.ns })\r\n  if (!secret) {\r\n    // console.log('Secret inconnu.')\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Secret inexistant.')\r\n  }\r\n\r\n  // calcul de v2 et de mpjs\r\n  const mpjs = !secret.mpjs ? {} : (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(secret.mpjs)\r\n  if (args.idc === null) {\r\n    if (args.idc === null) {\r\n      delete mpjs[args.cle]\r\n    } else {\r\n      mpjs[args.cle] = [args.idc, args.lg]\r\n    }\r\n  } else {\r\n    mpjs[args.cle] = [args.idc, args.lg]\r\n  }\r\n  let v = 0, deltav2 = 0, deltavm2 = 0\r\n  for (const c in mpjs) v += mpjs[c][1]\r\n  if (secret.st === 99999) { // permanent\r\n    deltav2 = v - secret.v2\r\n    deltavm2 = 0\r\n  } else {\r\n    deltav2 = 0\r\n    deltavm2 = v - secret.v2\r\n  }\r\n  if (deltav2 || deltavm2 && args.buf) {\r\n    const a = stmt(cfg, selavgrvqid).get({ id: args.id })\r\n    if (a) {\r\n      a.v2 = a.v2 + deltav2\r\n      a.vm2 = a.vm2 + deltavm2\r\n    }\r\n    if (!a || a.v1 > a.q1 || a.vm1 > a.qm1 || a.v2 > a.q2 || a.vm2 > a.qm2) {\r\n      console.log('Quotas d\\'espace insuffisants.')\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Quotas d\\'espace insuffisants.')\r\n    }\r\n  }\r\n\r\n  let secid = _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.idToSid(args.id) + '@' + _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.idToSid(args.ns)\r\n  if (args.ts === 1 && args.id2 < args.id) secid = _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.idToSid(args.id2) + '@' + _crypto_mjs__WEBPACK_IMPORTED_MODULE_0__.crypt.idToSid(args.ns2)\r\n\r\n  const pjid = args.idc ? args.cle + '@' + args.idc : null\r\n\r\n  if (args.idc) {\r\n    // stockage nouvelle version\r\n    await (0,_storage_mjs__WEBPACK_IMPORTED_MODULE_5__.putFile) (cfg, cfg.code, secid, pjid, args.buf)\r\n  }\r\n\r\n  const rowItems = []\r\n\r\n  try {\r\n    cfg.db.transaction(pjSecretTr)(cfg, args, rowItems)\r\n    // suppressions des anciennes versions (même clé) mais pas de la nouvelle \r\n    // SAUF si pjid est null auquel cas c'est une suppression\r\n    ;(0,_storage_mjs__WEBPACK_IMPORTED_MODULE_5__.delFile) (cfg, cfg.code, secid, args.cle, pjid)\r\n    _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n    setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n    return { sessionId: args.sessionId, dh: dh }\r\n  } catch (ex) {\r\n    // \"rollback\" sur stockage nouvelle version SAUF si pjid null (on ne supprime surtout pas)\r\n    if (pjid !== null) (0,_storage_mjs__WEBPACK_IMPORTED_MODULE_5__.delFile) (cfg, cfg.code, secid, null, pjid) \r\n    throw ex\r\n  }\r\n}\r\nm1fonctions.pjSecret = pjSecret\r\n\r\nfunction pjSecretTr (cfg, args, rowItems) {\r\n\r\n  const secret = stmt(cfg, selsecretidns).get({ id: args.id, ns: args.ns }) \r\n  if (!secret) {\r\n    // console.log('Secret inconnu.')\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Secret inexistant.')\r\n  }\r\n\r\n  secret.v = args.v\r\n  // calcul de v2 et de mpjs\r\n  const mpjs = !secret.mpjs ? {} : (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(secret.mpjs)\r\n  if (args.idc === null) {\r\n    delete mpjs[args.cle]\r\n  } else {\r\n    mpjs[args.cle] = [args.idc, args.lg]\r\n  }\r\n  let v = 0, deltav2 = 0, deltavm2 = 0\r\n  for (const c in mpjs) v += mpjs[c][1]\r\n  secret.mpjs = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(mpjs)\r\n  secret.v2 = v\r\n  rowItems.push(newItem('secret', secret))\r\n  stmt(cfg, upd2secret).run(secret)\r\n\r\n  let secret2\r\n  if (args.ts === 1) {\r\n    // secret2 PEUT avoir été détruit\r\n    secret2 = stmt(cfg, selsecretidns).get({ id: args.id2, ns: args.ns2 }) \r\n    if (secret2) {\r\n      secret2.v = args.vb\r\n      secret2.v2 = secret.v2\r\n      secret2.mpjs = secret.mpjs\r\n      stmt(cfg, upd2secret).run(secret2)\r\n      rowItems.push(newItem('secret', secret2))\r\n    }\r\n  }\r\n\r\n  if (secret.st === 99999) { // permanent\r\n    deltav2 = v - secret.v2\r\n    deltavm2 = 0\r\n  } else {\r\n    deltav2 = 0\r\n    deltavm2 = v - secret.v2\r\n  }\r\n  if (deltav2 || deltavm2) {\r\n    const a = stmt(cfg, selavgrvqid).get({ id: args.id })\r\n    if (a) {\r\n      a.v2 = a.v2 + deltav2\r\n      a.vm2 = a.vm2 + deltavm2\r\n      stmt(cfg, updavgrvq).run(a)\r\n    }\r\n\r\n    if (secret2) {\r\n      const a = stmt(cfg, selavgrvqid).get({ id: args.id2 })\r\n      if (a) {\r\n        a.v2 = a.v2 + deltav2\r\n        a.vm2 = a.vm2 + deltavm2\r\n        stmt(cfg, updavgrvq).run(a)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/******************************************************************\r\n * Parrainage : args de m1/nouveauParrainage\r\n  sessionId: data.sessionId,\r\n  rowParrain: serial(rowParrain)\r\n * Retour :\r\n * dh :\r\n */\r\nconst insparrain = 'INSERT INTO parrain (pph, id, v, st, dlv, q1, q2, qm1, qm2, datak, datax, data2k, ardc, vsh) '\r\n  + 'VALUES (@pph, @id, @v, @st, @dlv, @q1, @q2, @qm1, @qm2, @datak, @datax, @data2k, @ardc, @vsh)'\r\nconst selpphparrain = 'SELECT * FROM parrain WHERE pph = @pph'\r\n\r\nasync function nouveauParrainage (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n  const parrain = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(args.rowParrain)\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(parrain.id)\r\n  versions[j]++\r\n  setValue(cfg, VERSIONS)\r\n  parrain.v = versions[j] // version du row parrain\r\n\r\n  cfg.db.transaction(nouveauParrainageTr)(cfg, parrain)\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: [newItem('parrain', parrain)] })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return { sessionId: args.sessionId, dh: dh }\r\n}\r\nm1fonctions.nouveauParrainage = nouveauParrainage\r\n\r\nfunction nouveauParrainageTr (cfg, parrain) {\r\n  const p = stmt(cfg, selpphparrain).get({ pph: parrain.pph })\r\n  if (p) {\r\n    console.log('Parrain : phrase déjà utilisée')\r\n    const x = p.id === parrain.id ? ' par votre compte.' : ' par un autre compte.'\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Cette phrase de parrainage est trop proche d\\'une déjà enregistrée' + x)\r\n  }\r\n\r\n  stmt(cfg, insparrain).run(parrain)\r\n\r\n  // Retrait de quotas\r\n  const a = stmt(cfg, selavgrvqid).get({ id: parrain.id })\r\n  if (a) {\r\n    a.q1 = a.q1 - parrain.q1 * MO\r\n    a.q2 = a.q2 - parrain.q2 * MO\r\n    a.qm1 = a.qm1 - parrain.qm1 * MO\r\n    a.qm2 = a.qm2 - parrain.qm2 * MO\r\n  }\r\n  if (!a || a.v1 > a.q1 || a.vm1 > a.qm1 || a.v2 > a.q2 || a.vm2 > a.qm2) {\r\n    console.log('Quotas d\\'espace insuffisants.')\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Quotas d\\'espace insuffisants.')\r\n  }\r\n  stmt(cfg, updavgrvq).run(a)\r\n}\r\n\r\n/******************************************************************\r\n * Acceptation / refus d'un parrainage\r\n    sessionId: data.sessionId,\r\n    ok: true / false\r\n    pph: arg.pph,\r\n    idp: parrain.id,\r\n    icp: parrain.data.ic,\r\n  Si acceptation\r\n    idf: parrain.naf.id,\r\n    clePub: kp.publicKey,\r\n    rowCompte,\r\n    rowPrefs,\r\n    rowAvatar,\r\n    rowContactP,\r\n    rowContactF\r\n  Si refus\r\n    ardc\r\n * Retour : sessionId, dh, si ok : rowItems : compte, prefs, avatar, contactf\r\n */\r\nconst inscontact = 'INSERT INTO contact (id, ic, v, st, q1, q2, qm1, qm2, ardc, datak, datap, mc, infok, vsh) '\r\n + 'VALUES (@id, @ic, @v, @st, @q1, @q2, @qm1, @qm2, @ardc, @datak, @datap, @mc, @infok, @vsh)'\r\nconst upd1parrain = 'UPDATE parrain SET v = @v, st = @st, ardc = @ardc WHERE pph = @pph'\r\n\r\nasync function acceptParrainage (cfg, args) {\r\n  const session = checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n  const result = { sessionId: args.sessionId, dh: dh }\r\n  \r\n  const versions = getValue(cfg, VERSIONS)\r\n  let j = idx(args.idp)\r\n  versions[j]++\r\n  args.vp = versions[j] // version des rows parrain\r\n  if (args.ok) {\r\n    j = idx(args.idf)\r\n    versions[j]++\r\n    args.vf = versions[j] // version des rows filleul  \r\n  }\r\n  setValue(cfg, VERSIONS)\r\n\r\n  const compte = args.ok ? _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowcompte', args.rowCompte) : null\r\n  const avatar = args.ok ? _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowavatar', args.rowAvatar) : null\r\n  const prefs = args.ok ? _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowprefs', args.rowPrefs) : null\r\n  const contactf = args.ok ? _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowcontact', args.rowContactF) : null\r\n  const contactp = args.ok ? _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowcontact', args.rowContactP) : null\r\n  const items = {} // ne contient que parrain\r\n\r\n  cfg.db.transaction(acceptParrainageTr)(cfg, session, args, compte, avatar, prefs, contactf, contactp, items)\r\n\r\n  let rowItems\r\n  const i0 = newItem('parrain', items.parrain)\r\n  if (args.ok) {\r\n    const i1 = newItem('contact', contactp)\r\n    const i2 = newItem('contact', contactf)\r\n    const i3 = newItem('compte', compte)\r\n    const i4 = newItem('avatar', avatar)\r\n    const i5 = newItem('prefs', prefs)\r\n    rowItems = [i0, i1, i2, i3, i4, i5]\r\n    result.rowItems = [i3, i4, i5, i2]\r\n  } else {\r\n    rowItems = [i0]\r\n  }\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return result\r\n}\r\nm1fonctions.acceptParrainage = acceptParrainage\r\n  \r\nfunction acceptParrainageTr (cfg, session, args, compte, avatar, prefs, contactf, contactp, items) {\r\n  const p = stmt(cfg, selpphparrain).get({ pph: args.pph })\r\n  if (!p) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Phrase de parrainage inconnue')\r\n  }\r\n  const st = Math.floor(p.st / 10) \r\n  if (st!== 0) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Ce parrainage a déjà fait l\\'objet ' + (st === 1 ? 'd\\'une acceptation.' : 'd\\'un refus'))\r\n  }\r\n\r\n  if (args.ok) {\r\n    const c = stmt(cfg, selcomptedpbh).get({ dpbh: compte.dpbh })\r\n    if (c) {\r\n      if (c.pcbh === compte.pcbh) {\r\n        throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Phrase secrète probablement déjà utilisée. Vérifier que le compte n\\'existe pas déjà en essayant de s\\'y connecter avec la phrase secrète')\r\n      } else {\r\n        throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Une phrase secrète semblable est déjà utilisée. Changer a minima la première ligne de la phrase secrète pour ce nouveau compte')\r\n      }\r\n    }\r\n \r\n    // insertion des contacts p et f : v\r\n    contactp.v = args.vp\r\n    contactp.datap = null\r\n    stmt(cfg, inscontact).run(contactp)\r\n    contactf.v = args.vf\r\n    contactf.datap = null\r\n    stmt(cfg, inscontact).run(contactf)\r\n\r\n    // Insertion des nouveaux compte, avatar, prefs du filleul\r\n    compte.v = args.vf\r\n    avatar.v = args.vf\r\n    prefs.v = args.vf\r\n    compte.dds = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsc(0)\r\n    avatar.dds = _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dds.ddsag(0)\r\n    stmt(cfg, inscompte).run(compte)\r\n    stmt(cfg, insavatar).run(avatar)\r\n    stmt(cfg, insprefs).run(prefs)\r\n\r\n    // Clé RSA du filleul\r\n    const avrsa = { id: avatar.id, clepub: args.clePub, vsh: 0 }\r\n    stmt(cfg, insavrsa).run(avrsa)\r\n\r\n    // Quotas du filleul\r\n    const avgrvq = { id: avatar.id, q1: p.q1*MO, q2: p.q2*MO, qm1: p.qm1*MO, qm2:p.qm2*MO, v1: 0, v2:0, vm1:0, vm2: 0, vsh: 0 }\r\n    stmt(cfg, insavgrvq).run(avgrvq)\r\n\r\n    // Contexte de session du filleul\r\n    session.compteId = compte.id\r\n    session.plusAvatars([avatar.id])\r\n    session.plusCvs([contactp.id])\r\n  } else {\r\n    // Rétablir les quotas du parrain\r\n    const a = stmt(cfg, selavgrvqid).get({ id: p.id })\r\n    if (a) {\r\n      a.q1 = a.q1 + p.q1 * MO\r\n      a.q2 = a.q2 + p.q2 * MO\r\n      a.qm1 = a.qm1 + p.qm1 * MO\r\n      a.qm2 = a.qm2 + p.qm2 * MO\r\n    }\r\n    stmt(cfg, updavgrvq).run(a)\r\n  }\r\n  // MAJ du row parrain : v, st, ardc\r\n  p.v = args.vp\r\n  p.ardc = args.ok ? contactf.ardc : args.ardc\r\n  p.st = args.ok ? 1 : 2\r\n  stmt(cfg, upd1parrain).run(p)\r\n  items.parrain = p\r\n}\r\n\r\nasync function getPph (cfg, args) {\r\n  try {\r\n    const p = stmt(cfg, selpphparrain).get({ pph: args.pph })\r\n    if (!p) return { bytes0 }\r\n    const b = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.serial)(p)\r\n    return { bytes: b }\r\n  } catch (e) {\r\n    console.log(e)\r\n    return { bytes: bytes0 }\r\n  }\r\n}\r\nm1fonctions.getPph = getPph\r\n\r\n/* Régularisation Groupe *****************************************/\r\n/* args\r\n- id : de l'avatar\r\n- ni : numéro d'invitation du groupe à inscrire\r\n- datak : [nom, rnd, im] du groupe à inscrire\r\n*/\r\n\r\nconst upd1avatar = 'UPDATE avatar SET v = @v, lgrk = @lgrk WHERE id = @id'\r\nconst delinvitgr = 'DELETE from invitgr WHERE id = @id AND ni = @ni'\r\n\r\nasync function regulGr (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n  const result = { sessionId: args.sessionId, dh: dh }\r\n  \r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  args.v = versions[j] // version des rows parrain\r\n  setValue(cfg, VERSIONS)\r\n\r\n  const rowItems = []\r\n  cfg.db.transaction(regulGrTr)(cfg, args, rowItems)\r\n\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return result\r\n}\r\nm1fonctions.regulGR = regulGr\r\n\r\nfunction regulGrTr (cfg, args, rowItems) {\r\n  const a = stmt(cfg, selavatarid).get({ id: args.id })\r\n  if (!a) return // étrange\r\n  const map = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.deserial)(a.lgrk)\r\n  if (map[args.ni]) return // déjà fait\r\n  map[args.ni] = args.datak\r\n  a.v = args.v\r\n  stmt(cfg, upd1avatar).run(a)\r\n  rowItems.push(newItem('avatar', a))\r\n  stmt(cfg, delinvitgr).run({ id: args.id, ni: args.ni })\r\n}\r\n\r\n/* Régularisation Contact *****************************************/\r\n/* args\r\n- id : de l'avatar\r\n- ic : index du contact\r\n- datak : datak à insrire et mise à null de datap\r\n*/\r\n\r\nconst upd2contact = 'UPDATE contact SET v = @v, datak = @datak, datap = null WHERE id = @id AND ic = @ic'\r\n\r\nasync function regulCt (cfg, args) {\r\n  checkSession(args.sessionId)\r\n  const dh = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_1__.getdhc)()\r\n  const result = { sessionId: args.sessionId, dh: dh }\r\n  \r\n  const versions = getValue(cfg, VERSIONS)\r\n  const j = idx(args.id)\r\n  versions[j]++\r\n  args.v = versions[j] // version des rows parrain\r\n  setValue(cfg, VERSIONS)\r\n\r\n  const rowItems = []\r\n  cfg.db.transaction(regulCtTr)(cfg, args, rowItems)\r\n\r\n  _session_mjs__WEBPACK_IMPORTED_MODULE_2__.syncListQueue.push({ sessionId: args.sessionId, dh: dh, rowItems: rowItems })\r\n  setImmediate(() => { ;(0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.processQueue)() })\r\n  return result\r\n}\r\nm1fonctions.regulCt = regulCt\r\n\r\nfunction regulCtTr (cfg, args, rowItems) {\r\n  const c = stmt(cfg, selcontactIdIc).get({ id: args.id, ic: args.ic })\r\n  if (!c || c.datap === null) return // étrange ou déjà fait\r\n  c.c = args.v\r\n  c.datak = args.datak\r\n  stmt(cfg, upd2contact).run(c)\r\n  rowItems.push(newItem('contact', c))\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/m1.mjs?");

/***/ }),

/***/ "./src/schemas.mjs":
/*!*************************!*\
  !*** ./src/schemas.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schemas\": () => (/* binding */ schemas)\n/* harmony export */ });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"./src/util.mjs\");\n\r\nconst schemas = { forSchema, serialize, deserialize, test }\r\n\r\n/* Gestion des schémas **************************************************/\r\nconst allTypes = {}\r\n\r\nfunction forSchema (s) {\r\n  if (s && s.name) allTypes[s.name] = s\r\n  return s\r\n}\r\n\r\nfunction serialize (s, src) {\r\n  const sch = allTypes[s]\r\n  if (!sch || !sch.cols) return (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.serial)(src)\r\n  const x = {}\r\n  sch.cols.forEach((col) => { x[col] = src[col] })\r\n  return (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.serial)(x)\r\n}\r\n\r\nfunction deserialize (s, buf, dest) {\r\n  const obj = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.deserial)(buf)\r\n  const sch = allTypes[s]\r\n  if (!sch || !sch.cols) {\r\n    if (!dest) return obj\r\n    for (const f in obj) dest[f] = obj[f]\r\n    return dest\r\n  }\r\n  const x = {}\r\n  sch.cols.forEach((col) => {\r\n    if (dest) {\r\n      dest[col] = obj[col]\r\n    } else {\r\n      x[col] = obj[col]\r\n    }\r\n  })\r\n  return dest || x\r\n}\r\n\r\nfunction test () {\r\n  const sch = { name: 'test', cols: ['nom', 'age'] }\r\n  const obj1 = { nom: 'Daniel', age: 62, taille: 182 }\r\n\r\n  forSchema(sch)\r\n  const buf2 = serialize('test', obj1)\r\n  const obj2b = deserialize('test', buf2)\r\n  console.log(JSON.stringify(obj2b))\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/schemas.mjs?");

/***/ }),

/***/ "./src/server.mjs":
/*!************************!*\
  !*** ./src/server.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony import */ var _session_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./session.mjs */ \"./src/session.mjs\");\n/* harmony import */ var _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webcrypto.mjs */ \"./src/webcrypto.mjs\");\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _storage_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage.mjs */ \"./src/storage.mjs\");\n/* harmony import */ var _m1_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./m1.mjs */ \"./src/m1.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/server.mjs\")\r\n\r\nconst fs = require('fs')\r\nconst http = require('http')\r\nconst https = require('https')\r\nconst process = require('process')\r\nconst path = require('path')\r\nconst express = require('express')\r\nconst WebSocket = require('ws')\r\n;\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst modules = { m1: _m1_mjs__WEBPACK_IMPORTED_MODULE_5__.m1fonctions }\r\n\r\nconst dev = process.env.NODE_ENV === 'development'\r\n\r\n/* \r\nvérification que l'origine appartient à la liste des origines autorisées (q'il y en a une)\r\nlocalhost passe toujours\r\n*/\r\nfunction checkOrigin(req) {\r\n  if (!cfg.origins || !cfg.origins.length) return true\r\n  let origin = req.headers['origin']\r\n  if (!origin || origin === 'null') {\r\n    const referer = req.headers['referer'];\r\n    if (referer) {\r\n      const i = referer.indexOf('/', 10);\r\n      if (i !== -1)\r\n        origin = referer.substring(0, i);\r\n    }\r\n  }\r\n  if (!origin || origin === 'null')\r\n    origin = req.headers['host'];\r\n  if (origin && origin.startsWith('http://localhost'))\r\n    origin = 'localhost'\r\n  if (cfg.origins.indexOf(origin) !== -1) return true\r\n  console.log('Origine refusée : ' + origin)\r\n  return false\r\n}\r\n\r\n// positionne les headers et le status d'une réponse. Permet d'accepter des requêtes cross origin des browsers\r\nfunction setRes(res, status, respType) {\r\n  res.status(status).set({\r\n    'Access-Control-Allow-Origin' : '*',\r\n    'Access-Control-Allow-Methods' : 'GET,POST,PUT,DELETE,OPTIONS',\r\n    'Access-Control-Allow-Headers': 'Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With, X-API-version'\r\n  })\r\n  return res.type(respType ? respType : 'application/octet-stream')\r\n}\r\n\r\nfunction er(c) {\r\n  const l = [\r\n    'Erreur non récupérée : ', // 0\r\n    'Origine non autorisée', // 1\r\n    'Module inconnu', // 2\r\n    'Fonction inconnue', // 3\r\n    'Organisation inconnue', // 4\r\n    'Version d\\'API incompatble', // 5\r\n    'File not found' // 6\r\n  ]\r\n  throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.E_SRV, l[c])\r\n}\r\n\r\n/*\r\nTraitement générique d'une opération\r\n*/\r\nasync function operation(req, res) {\r\n  let pfx = new Date().toISOString() // prefix de log\r\n  try {\r\n    const isGet = req.method === 'GET'\r\n    // vérification de l'origine de la requête\r\n    if (!checkOrigin(req)) {\r\n      setRes(res, 402).send(er(1))\r\n      return\r\n    }\r\n    // récupération du module traitant l'opération\r\n    const mod = modules[req.params.mod]\r\n    if (!mod) {\r\n      setRes(res, 402).send(er(2))\r\n      return\r\n    }\r\n    // récupétration de la fonction de ce module traitant l'opération\r\n    const f = req.params.func\r\n    const func = mod[f]\r\n    if (!func) {\r\n      setRes(res, 402).send(er(3))\r\n      return\r\n    }\r\n    // reconnaissance de l'organisation\r\n    const cfgorg = cfg.orgs[req.params.org]\r\n    if (!cfgorg) {\r\n      setRes(res, 402).send(er(4))\r\n      return\r\n    }\r\n    // vérification de la version de l'API\r\n    const apiv = req.headers['x-api-version']\r\n    if (apiv && apiv !== _api_mjs__WEBPACK_IMPORTED_MODULE_3__.version) {\r\n      setRes(res, 402).send(er(5))\r\n      return\r\n    }\r\n\r\n    /***************************************************************\r\n    Appel de l'opération\r\n        cfg : configuration relative au code de l'organisation    \r\n        args : objet des arguments\r\n    Retourne un objet result :\r\n    Pour un GET :\r\n        result.type : type mime\r\n        result.bytes : si le résultat est du binaire\r\n    Pour un POST :\r\n        OK : result : objet résultat à sérialiser - HTTP status 200\r\n\r\n    Exception : \r\n        AppExc : AppExc sérialisé en JSON\r\n            code > 0 - erreur fonctionnelle à retourner par l'application\r\n                HTTP status 400\r\n            code < 0 - erreur fonctionnelle à émettre en exception à l'application\r\n                HTTP status 401                   \r\n        Inattendue : Création d'un AppExc avec code < 0 sérialisé en JSON\r\n            HTTP status 402\r\n    *****************************************************************/\r\n    const args = isGet ? req.query : (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_6__.decode)(req.body)\r\n    pfx += ' func=' + req.params.mod + '/' + req.params.func + ' org=' + req.params.org\r\n    if (dev) console.log(pfx)\r\n    const result = await func(cfgorg, args, isGet)\r\n    if (dev) console.log(pfx + ' 200')\r\n    if (isGet)\r\n      setRes(res, 200, result.type || 'application/octet-stream').send(Buffer.from(result.bytes))\r\n    else {\r\n      setRes(res, 200).send(Buffer.from((0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_7__.encode)(result)))\r\n    }         \r\n  } catch(e) {\r\n    let httpst\r\n    let s\r\n    // exception non prévue ou prévue\r\n    if (e instanceof _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc) { // erreur trappée déjà mise en forme en tant que AppExc \r\n      httpst = e.code === _api_mjs__WEBPACK_IMPORTED_MODULE_3__.F_SRV ? 400 : (e.code === _api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV ? 401 : 402)\r\n      s = e.toString() // JSON\r\n    } else {\r\n      // erreur non trappée : mise en forme en AppExc\r\n      httpst = 402\r\n      const xx = (e.stack ? e.stack + '\\n' : '') + lastSql.join('\\n')\r\n      s = new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.E_SRV, e.message, xx).toString()\r\n    }\r\n    if (dev) console.log(pfx + ' ' + httpst + ' : ' + s)\r\n    setRes(res, httpst).send(Buffer.from(s))\r\n  }\r\n}\r\n\r\nconst dirs = { configdir: './config', dbdir: './databases' }\r\nprocess.argv.forEach((arg) => {\r\n  if (arg.startsWith('configdir=')) dirs.configdir = arg.substring('configdir='.length)\r\n  if (arg.startsWith('dbdir=')) dirs.dbdir = arg.substring('dbdir='.length)\r\n})\r\n\r\nconsole.log('configdir=' + path.resolve(dirs.configdir))\r\nconsole.log('dbdir=' + path.resolve(dirs.dbdir))\r\n\r\n/*\r\nRécupération de la configuration\r\nDans la configuration de chaque environnement, son code est inséré\r\n*/\r\nconst salts = fs.readFileSync(path.resolve(dirs.configdir, './salts'))\r\n// eslint-disable-next-line no-unused-vars\r\nconst salts2 = fs.readFileSync('./src/assets/salts.png')\r\n;(0,_webcrypto_mjs__WEBPACK_IMPORTED_MODULE_2__.setSalts) (salts)\r\n\r\nconst lastSql = []\r\nfunction trapSql (msg) {\r\n  if (dev) console.log(msg)\r\n  lastSql.unshift(msg)\r\n  if (lastSql.length > 3) lastSql.length = 3\r\n}\r\n\r\nconst configjson = fs.readFileSync(path.resolve(dirs.configdir, './config.json'))\r\nlet cfg\r\ntry {\r\n  const options = { fileMustExist: true, verbose: trapSql }\r\n  cfg = JSON.parse(configjson)\r\n  for(const org in cfg.orgs) {\r\n    const e = cfg.orgs[org]\r\n    e.code = org\r\n    e.isDev = dev\r\n    e.wwwdir = cfg.wwwdir\r\n    e.db = require('better-sqlite3')(path.resolve(dirs.dbdir, org + '.db3'), options);\r\n  }\r\n} catch(e) {\r\n  throw new Error(' Erreur de parsing de config.json : ' + e.message)\r\n}\r\n\r\n// Les sites appelent souvent favicon.ico\r\nconst favicon = fs.readFileSync(path.resolve(dirs.configdir, './favicon.ico'))\r\n// const deficon = 'data:image/png;base64,' + fs.readFileSync('./anonymous.png', 'base64')\r\n\r\nconst app = express()\r\napp.use(express.json()) // parsing des application/json\r\n\r\n// OPTIONS est toujours envoyé pour tester les appels cross origin\r\napp.use('/', (req, res, next) => {\r\n  if (req.method === 'OPTIONS')\r\n    setRes(res, 200, 'text/plain').send('')\r\n  else\r\n    next()\r\n})\r\n\r\n/**** favicon.ico du sites ****/\r\napp.get('/favicon.ico', (req, res) => {\r\n  setRes(res, 200, 'image/x-icon').send(favicon)\r\n})\r\n\r\n/**** ping du site ****/\r\napp.get('/ping', (req, res) => {\r\n  setRes(res, 200, 'text/plain').send(new Date().toISOString())\r\n})\r\n\r\napp.use('/www/:org/:secid/:pjid', async (req, res) => {\r\n  if (!checkOrigin(req)) {\r\n    setRes(res, 402).send('Origine non autorisée')\r\n    return\r\n  }\r\n  const cfgorg = cfg.orgs[req.params.org]\r\n  if (!cfgorg) {\r\n    setRes(res, 402).send('Organisation inconnue')\r\n    return\r\n  }\r\n  const p = req.params\r\n  const bytes = await (0,_storage_mjs__WEBPACK_IMPORTED_MODULE_4__.getFile)(cfg, p.org, p.secid, p.pjid)\r\n  if (bytes) {\r\n    // putFile(cfg, p.org, p.secid, p.pjid, bytes) // pour test\r\n    setRes(res, 200, 'application/octet-stream').send(bytes)\r\n  } else {\r\n    setRes(res, 404).send('File not found')\r\n  }\r\n})\r\n\r\n/**** appels des opérations ****/\r\napp.use('/:org/:mod/:func', async (req, res) => {\r\n  // push the data to body\r\n  const body = [];\r\n  req.on('data', (chunk) => {\r\n    body.push(chunk);\r\n  }).on('end', async () => {\r\n    req.body = Buffer.concat(body)\r\n    await operation(req, res)\r\n  })\r\n})\r\n\r\n// fonction appelée juste après l'écoute. Initialise les modules sur leurs fonctiopns atStart\r\nfunction atStart() {\r\n  for (const m in modules) {\r\n    const mod =  modules[m]\r\n    if (mod && mod.atStart) mod.atStart(cfg)\r\n  }\r\n}\r\n\r\n/****** starts listen ***************************/\r\n// Pour installation sur o2switch\r\n// https://faq.o2switch.fr/hebergement-mutualise/tutoriels-cpanel/app-nodejs\r\nconst isPassenger = typeof(PhusionPassenger) !== 'undefined'\r\nif (isPassenger) {\r\n  // eslint-disable-next-line no-undef\r\n  PhusionPassenger.configure({ autoInstall: false })\r\n}\r\n\r\nconsole.log('isPassenger:' + isPassenger)\r\n\r\ntry {\r\n  let server\r\n  const port = isPassenger ? 'passenger' : (cfg.port || (!cfg.https ? 8080 : 8443))\r\n  // Création en http ou 'passenger'\r\n  if (!cfg.https)\r\n    server = http.createServer(app).listen(port, () => {\r\n      console.log('HTTP server running on port ' + port)\r\n      try {\r\n        atStart()\r\n      } catch (e) {\r\n        console.log('HTTP server atStart erreur : ' + e.message)\r\n      }\r\n    })\r\n  else {\r\n    // Création en https avec un certificat et sa clé de signature\r\n    const key = fs.readFileSync(path.resolve(dirs.configdir, './privkey.pem'))\r\n    const cert = fs.readFileSync(path.resolve(dirs.configdir, './fullchain.pem'))\r\n    server = https.createServer({key:key, cert:cert}, app).listen(port, () => {\r\n      console.log('HTTP/S server running on port ' + port)\r\n      try {\r\n        atStart()\r\n      } catch (e) {\r\n        console.log('HTTP server atStart erreur : ' + e.message)\r\n      }\r\n    });\t\t\r\n  }\r\n  server.on('error', (e) => { // les erreurs de création du server ne sont pas des exceptions\r\n    console.error('server.js : HTTP error = ' + e.message)\r\n  })\r\n\r\n  const wss = new WebSocket.Server({ server })\r\n  wss.on('connection', (ws, request) => {\r\n    if (checkOrigin(request)) {\r\n      new _session_mjs__WEBPACK_IMPORTED_MODULE_1__.Session (ws, request, wss)\r\n    } else {\r\n      ws.close()\r\n    }\r\n  })\r\n\r\n} catch(e) { // exception générale. Ne devrait jamais être levée\r\n  console.error('server.js : catch global = ' + e.message)\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/server.mjs?");

/***/ }),

/***/ "./src/session.mjs":
/*!*************************!*\
  !*** ./src/session.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSession\": () => (/* binding */ getSession),\n/* harmony export */   \"Session\": () => (/* binding */ Session),\n/* harmony export */   \"syncSessions\": () => (/* binding */ syncSessions),\n/* harmony export */   \"syncListQueue\": () => (/* binding */ syncListQueue),\n/* harmony export */   \"processQueue\": () => (/* binding */ processQueue)\n/* harmony export */ });\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.mjs */ \"./src/util.mjs\");\n\r\n\r\n\r\n\r\nconst dev = \"development\" === 'development'\r\n\r\nconst sessions = new Map()\r\n\r\nfunction getSession (id) { return sessions.get(id) }\r\n\r\nconst sessionsmortes = new Set()\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nconst gcSessions = setInterval(() => {\r\n  const dh1 = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getdhc)()\r\n  const max = _api_mjs__WEBPACK_IMPORTED_MODULE_0__.PINGTO * 6 * 10000\r\n  sessionsmortes.clear()\r\n  sessions.forEach((session, sessionId) => {\r\n    const dh2 = session.dhping\r\n    if (dh2 !== 0 && (dh1 - dh2 > max)) sessionsmortes.add(sessionId)\r\n  })\r\n  sessionsmortes.forEach((sid) => {\r\n    sessions.delete(sid)\r\n  })\r\n  sessionsmortes.clear()\r\n}, _api_mjs__WEBPACK_IMPORTED_MODULE_0__.PINGTO * 1000)\r\n\r\n/* Appelé sur l'événement 'connection' reçu du Web Server\r\n- request : requête Http correspondante : on ne sait rien en faire a priori\r\n- wss1 : server web socket\r\n*/\r\nclass Session {\r\n  constructor (ws /*, request, wss1*/) {\r\n    this.ws = ws\r\n    this.dhping = 0\r\n    this.sessionId = null\r\n    this.compteId = null\r\n    this.avatarsIds = new Set() // Set\r\n    this.groupesIds = new Set // Set\r\n    this.cvsIds = new Set() // Set\r\n    this.nbpings = 0\r\n    this.ws.onerror = (e) => {\r\n      console.log(e)\r\n      if (this.sessionId)\r\n        sessions.delete(this.sessionId)\r\n    }\r\n    this.ws.onclose = (/* e */) => {\r\n      if (this.sessionId)\r\n        sessions.delete(this.sessionId)\r\n      if (dev) console.log('Fermeture de session détectée:' + this.sessionId)\r\n    }\r\n    this.ws.onmessage = (m) => {\r\n      // seul message reçu : ping avec le sessionid\r\n      this.nbpings++\r\n      const newid = m.data\r\n      const d = new Date()\r\n      this.dhping = d.getTime()\r\n      if (newid !== this.sessionId) {\r\n        // nouvelle session\r\n        if (this.sessionId) {\r\n          sessions.delete(this.sessionId)\r\n        }\r\n        this.sessionId = newid\r\n        sessions.set(newid, this)\r\n        if (dev) console.log('Ouverture de session reçue: ' + newid + ' / ' + d.toISOString())\r\n      } else {\r\n        if (dev) console.log('Ping reçu: ' + newid + ' / ' + d.toISOString())\r\n      }\r\n      // réponse pong\r\n      if (this.nbpings < 1000000) { // pour tester et ne plus envoyer de pong au delà de N pings\r\n        const pong = { sessionId: newid, dh: (0,_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getdhc)(), syncList: null }\r\n        const buf = _schemas_mjs__WEBPACK_IMPORTED_MODULE_1__.schemas.serialize('synclist', pong)\r\n        this.ws.send(buf)\r\n      }\r\n    }    \r\n  }\r\n\r\n  plusAvatars (ar) {\r\n    if (ar && ar.length) ar.forEach(id => { this.avatarsIds.add(id) })\r\n  }\r\n\r\n  plusGroupes (ar) {\r\n    if (ar && ar.length) ar.forEach(id => { this.groupesIds.add(id) })\r\n  }\r\n\r\n  plusCvs (ar) {\r\n    if (ar && ar.length) ar.forEach(id => { this.cvsIds.add(id) })\r\n  }\r\n\r\n  aavatar (rowItem) {\r\n    return this.avatarsIds && this.avatarsIds.has(rowItem.id)\r\n  }\r\n\r\n  agroupe (rowItem) {\r\n    return this.groupesIds && this.groupesIds.has(rowItem.id)\r\n  }\r\n\r\n  acv (rowItem) {\r\n    return this.cvsIds && this.cvsIds.has(rowItem.id)\r\n  }\r\n\r\n  send (data) {\r\n    this.ws.send(data)\r\n  }\r\n\r\n  traiteSyncList (syncList) { // syncList : { sessionId, dh, rowItems }\r\n    // filtre dans rowItems ceux concernés par la session et envoie (éventuellement) le message\r\n    const msg = { sessionId: this.sessionId, dh: syncList.dh, rowItems: [] }\r\n    syncList.rowItems.forEach((rowItem) => {\r\n      switch (rowItem.table) {\r\n      case 'avatar' : {\r\n        if (this.aavatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'compte' : {\r\n        if (rowItem.id === this.compteId) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'prefs' : {\r\n        if (rowItem.id === this.compteId) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'contact' : {\r\n        if (this.aavatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'groupe' : {\r\n        if (this.agroupe(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'invitct' : {\r\n        if (this.aavatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'invitgr' : {\r\n        if (this.avatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'membre' : {\r\n        if (this.agroupe(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'parrain' : {\r\n        if (this.aavatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'rencontre' : {\r\n        if (this.avatar(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'secret' : {\r\n        if (this.aavatar(rowItem) || this.agroupe(rowItem) ) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      case 'cv' : {\r\n        if (this.acv(rowItem)) msg.rowItems.push(rowItem)\r\n        break\r\n      }\r\n      }\r\n    })\r\n    if (msg.rowItems.length) {\r\n      const buf = _schemas_mjs__WEBPACK_IMPORTED_MODULE_1__.schemas.serialize('syncList', msg)\r\n      setImmediate(() => {\r\n        this.send(buf)\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nfunction syncSessions(rows, delobjs) {\r\n  rows.forEach(row => {\r\n    delete row.datax\r\n    delete row.datay\r\n  })\r\n  for (const s of sessions) {\r\n    sessions[s].sync(rows, delobjs)\r\n  }\r\n}\r\n\r\nconst syncListQueue = [] // array de syncList : { sessionId, dh, rowItems }\r\n\r\nfunction processQueue() {\r\n  while (syncListQueue.length) {\r\n    const syncList = syncListQueue[0]\r\n    sessions.forEach((session) => {\r\n      if (syncList.rowItems.length) session.traiteSyncList(syncList)\r\n    })\r\n    syncListQueue.splice(0, 1)\r\n  }\r\n}\n\n//# sourceURL=webpack://boitessrv/./src/session.mjs?");

/***/ }),

/***/ "./src/storage.mjs":
/*!*************************!*\
  !*** ./src/storage.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getFile\": () => (/* binding */ getFile),\n/* harmony export */   \"putFile\": () => (/* binding */ putFile),\n/* harmony export */   \"delFile\": () => (/* binding */ delFile)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n\r\n\r\n\r\n\r\nasync function getFile (cfg, org, secid, pjid) {\r\n  try {\r\n    const p = path__WEBPACK_IMPORTED_MODULE_1__.resolve(cfg.wwwdir, org, secid, pjid)\r\n    return await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(p)\r\n  } catch (err) {\r\n    // console.log(err.toString())\r\n    return null\r\n  }\r\n}\r\n\r\nasync function putFile (cfg, org, secid, pjid, data) {\r\n  const x = secid === 'secret1' ? 'secret2' : secid // pour test\r\n  const dir = path__WEBPACK_IMPORTED_MODULE_1__.resolve(cfg.wwwdir, org, x)\r\n  if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(dir)) fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync(dir, { recursive: true })\r\n  await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(path__WEBPACK_IMPORTED_MODULE_1__.resolve(dir, pjid), data)\r\n}\r\n\r\n/*\r\nSi cle != null: suppression de TOUS les fichiers qui commencent par cle@ ... SAUF pjid si pjid non null\r\nSi pjid non null et cle null : suppression DU fichier pjid (qui d'ailleurs commen,ce par cle@...)\r\n*/\r\nfunction delFile (cfg, org, secid, cle, pjid) {\r\n  try {\r\n    const dir = path__WEBPACK_IMPORTED_MODULE_1__.resolve(cfg.wwwdir, org, secid)\r\n    if (fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(dir)) {\r\n      if (!cle) {\r\n        fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync(path__WEBPACK_IMPORTED_MODULE_1__.resolve(dir, pjid))\r\n      } else {\r\n        const files = fs__WEBPACK_IMPORTED_MODULE_0__.readdirSync(dir)\r\n        if (files && files.length) files.forEach(name => {\r\n          if ((!pjid || name !== pjid) && name.startsWith(cle + '@')) fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync(path__WEBPACK_IMPORTED_MODULE_1__.resolve(dir, name));\r\n        })\r\n      }\r\n    }\r\n  } catch (err) {\r\n    console.log(err.toString())\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/storage.mjs?");

/***/ }),

/***/ "./src/util.mjs":
/*!**********************!*\
  !*** ./src/util.mjs ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"u8ToString\": () => (/* binding */ u8ToString),\n/* harmony export */   \"stringToU8\": () => (/* binding */ stringToU8),\n/* harmony export */   \"serial\": () => (/* binding */ serial),\n/* harmony export */   \"deserial\": () => (/* binding */ deserial),\n/* harmony export */   \"getdhc\": () => (/* binding */ getdhc),\n/* harmony export */   \"sleep\": () => (/* binding */ sleep),\n/* harmony export */   \"dds\": () => (/* binding */ dds),\n/* harmony export */   \"j99\": () => (/* binding */ j99)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/util.mjs\")\r\n\r\nconst now = require('nano-time')\r\n\r\n;\r\n\r\nconst decoder = new TextDecoder('utf-8')\r\nconst encoder = new TextEncoder('utf-8')\r\n\r\nfunction u8ToString (u8) { return decoder.decode(u8) }\r\nfunction stringToU8 (str) { return encoder.encode(str) }\r\n\r\nfunction serial (obj) {\r\n  return new Uint8Array((0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.encode)(obj))\r\n}\r\n\r\nfunction deserial (u8) {\r\n  return (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decode)(u8)\r\n}\r\n\r\nfunction getdhc() {\r\n  return parseInt(now.micro(), 10)\r\n}\r\n\r\nfunction sleep (delai) {\r\n  if (delai <= 0) return\r\n  return new Promise((resolve) => { setTimeout(() => resolve(), delai) })\r\n}\r\n\r\nconst j0 = Math.floor(new Date('2020-01-01T00:00:00').getTime() / 86400000)\r\n\r\nclass Dds {  \r\n  // jour courant (nombre de jours écoulés) depuis le 1/1/2020\r\n  jourJ (date) {\r\n    const d = date || new Date()\r\n    return Math.floor(d.getTime() / 86400000) - j0\r\n  }\r\n\r\n  semaine (j) {\r\n    const ns = Math.floor((j + 1) / 7) + 1\r\n    const nj = ((j + 1) % 7) + 1\r\n    return [ns, nj]\r\n  }\r\n\r\n  aaaammjj (j) {\r\n    return new Date((j0 + j) * 86400000).toISOString().substring(0, 10)\r\n  }\r\n\r\n  /* \r\n  Si la dds actuelle du compte n'a pas plus de 28 jours, elle convient encore.\r\n  Sinon il faut en réattribuer une qui ait entre 14 et 28 jours d'âge.\r\n  */\r\n  ddsc (dds) {\r\n    const j = this.jourJ()\r\n    return ((j - dds) > 28) ? j - 14 - Math.floor(Math.random() * 14) : dds\r\n  }\r\n\r\n  /* \r\n  Si la dds actuelle de l'avatar ou du groupe n'a pas plus de 14 jours, elle convient encore.\r\n  Sinon il faut en réattribuer une qui ait entre 0 et 14 d'âge.\r\n  */\r\n  ddsag (dds) {\r\n    const j = this.jourJ()\r\n    return ((j - dds) > 14) ? j - Math.floor(Math.random() * 14) : dds\r\n  }\r\n}\r\nconst dds = new Dds()\r\n\r\nconst j99 = dds.jourJ(new Date('2099-12-31T23:59:59')) // 29220 = 365 * 80 + 20 (années bisextiles)\r\n// console.log('j99 = ' + j99)\r\n\r\n/* Mois courant depuis janvier 2020 */\r\n// eslint-disable-next-line no-unused-vars\r\nfunction getMois () {\r\n  const d = new Date()\r\n  const an = (d.getUTCFullYear() % 100) - 20\r\n  const mo = d.getUTCMonth()\r\n  return ( (an * 12) + mo)\r\n}\r\n\r\n/*\r\nlet j1 = 1\r\nconsole.log(dds.aaaammjj(j1))\r\nconst [ns, nj] = dds.semaine(j1)\r\nconsole.log(ns + ' / ' + nj)\r\nj1 = 367\r\nconsole.log(dds.aaaammjj(j1))\r\nconst [ns2, nj2] = dds.semaine(j1)\r\nconsole.log(ns2 + ' / ' + nj2)\r\n*/\r\n\n\n//# sourceURL=webpack://boitessrv/./src/util.mjs?");

/***/ }),

/***/ "./src/webcrypto.mjs":
/*!***************************!*\
  !*** ./src/webcrypto.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SALTS\": () => (/* binding */ SALTS),\n/* harmony export */   \"setSalts\": () => (/* binding */ setSalts),\n/* harmony export */   \"u8ToB64\": () => (/* binding */ u8ToB64),\n/* harmony export */   \"b64ToU8\": () => (/* binding */ b64ToU8),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256),\n/* harmony export */   \"pbkfd\": () => (/* binding */ pbkfd),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"crypter\": () => (/* binding */ crypter),\n/* harmony export */   \"decrypter\": () => (/* binding */ decrypter),\n/* harmony export */   \"decrypterStr\": () => (/* binding */ decrypterStr),\n/* harmony export */   \"genKeyPair\": () => (/* binding */ genKeyPair),\n/* harmony export */   \"crypterRSA\": () => (/* binding */ crypterRSA),\n/* harmony export */   \"decrypterRSA\": () => (/* binding */ decrypterRSA),\n/* harmony export */   \"concat\": () => (/* binding */ concat)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _base64_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.mjs */ \"./src/base64.mjs\");\n/*********************************************** \r\nIMPLEMENTATION de webcrypto.js EN UTILISANT NODE (crypto)\r\n************************************************/\r\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/webcrypto.mjs\")\r\n\r\nconst crypto = require('crypto')\r\n\r\n;\r\n\r\nconst dec = new TextDecoder()\r\n\r\nconst SALTS = new Array(256)\r\nfunction setSalts (a) {\r\n  const b = new Uint8Array(a)\r\n  for (let i = 0; i < 256; i++) {\r\n    SALTS[i] = Uint8Array.prototype.slice.call(b, i * 16, (i + 1) * 16)\r\n  }\r\n}\r\n\r\nfunction u8ToB64 (u8, url) {\r\n  const s = (0,_base64_mjs__WEBPACK_IMPORTED_MODULE_1__.fromByteArray)(u8)\r\n  if (!url) return s\r\n  return s.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\r\n}\r\n\r\nfunction b64ToU8 (s) {\r\n  const diff = s.length % 4\r\n  let x = s\r\n  if (diff) {\r\n    const pad = '===='.substring(0, 4 - diff)\r\n    x = s + pad\r\n  }\r\n  return (0,_base64_mjs__WEBPACK_IMPORTED_MODULE_1__.toByteArray)(x.replace(/-/g, '+').replace(/_/g, '/'))\r\n}\r\n\r\nfunction sha256 (buffer) {\r\n  return crypto.createHash('sha256').update(buffer).digest()\r\n}\r\n\r\nasync function pbkfd (secret) {\r\n  return crypto.pbkdf2Sync(secret, SALTS[0], 5000, 32, 'sha256')\r\n}\r\n\r\nfunction random (nbytes) { return crypto.randomBytes(nbytes) }\r\n\r\nasync function crypter (cle, buffer, idxIV) {\r\n  const k = typeof cle === 'string' ? b64ToU8(cle) : cle\r\n  const n = !idxIV ? Number(crypto.randomBytes(1)) : idxIV\r\n  const cipher = crypto.createCipheriv('aes-256-cbc', k, SALTS[n])\r\n  const x0 = new Uint8Array(1)\r\n  x0[0] = n\r\n  const x1 = cipher.update(buffer)\r\n  const x2 = cipher.final()\r\n  return Buffer.concat([x0, x1, x2])\r\n}\r\n\r\nasync function decrypter (cle, buffer) {\r\n  const k = typeof cle === 'string' ? b64ToU8(cle) : cle\r\n  const decipher = crypto.createDecipheriv('aes-256-cbc', k, SALTS[Number(buffer[0])])\r\n  const x1 = decipher.update(buffer.slice(1))\r\n  const x2 = decipher.final()\r\n  return Buffer.concat([x1, x2])\r\n}\r\n\r\nasync function decrypterStr (cle, buffer) {\r\n  const buf = decrypter(cle, buffer)\r\n  return dec.decode(buf)\r\n}\r\n\r\nasync function genKeyPair () {\r\n  return crypto.generateKeyPairSync('rsa',\r\n    {\r\n      modulusLength: 2048, // the length of your key in bits\r\n      publicKeyEncoding: {\r\n        type: 'spki', // recommended to be 'spki' by the Node.js docs\r\n        format: 'pem'\r\n      },\r\n      privateKeyEncoding: {\r\n        type: 'pkcs8', // recommended to be 'pkcs8' by the Node.js docs\r\n        format: 'pem'\r\n        // cipher: 'aes-256-cbc',   // *optional*\r\n        // passphrase: 'top secret' // *optional*\r\n      }\r\n    })\r\n}\r\n\r\n/* encryption RSA avec la clé publique\r\n  data est un Buffer\r\nconst pad1 = crypto.RSA_PKCS1_OAEP_PADDING_SHA1\r\nconst pad2 = crypto.constants.RSA_PKCS1_OAEP_PADDING\r\nconst pad3 = crypto.constants.RSA_PKCS1_PADDING\r\n*/\r\nconst pad4 = crypto.constants.RSA_NO_PADDING\r\n\r\nasync function crypterRSA (publicKey, data) {\r\n  return crypto.publicEncrypt({ key: publicKey /*, padding: pad3, oaepHash: 'sha256' */ }, data)\r\n}\r\n\r\n/* decryption RSA avec la clé privée\r\n  encryptedData est un Buffer\r\n*/\r\nasync function decrypterRSA (privateKey, encryptedData) {\r\n  // !!! Web API ne peut être décrypté que sans padding !!!\r\n  return crypto.privateDecrypt({ key: privateKey, padding: pad4 /*, oaepHash: 'sha256' */ }, encryptedData)\r\n}\r\n\r\nfunction concat (arrays) {\r\n  // sum of individual array lengths\r\n  const totalLength = arrays.reduce((acc, value) => acc + value.length, 0)\r\n  if (!arrays.length) return null\r\n  const result = new Uint8Array(totalLength)\r\n  let length = 0\r\n  for (const array of arrays) {\r\n    result.set(array, length)\r\n    length += array.length\r\n  }\r\n  return result\r\n}\r\n\r\n/* Tests comparatifs Web API crypto et Node crypto *********\r\nexport async function testWAC () {\r\n  let cle = 'toto est beau'\r\n  let clebin = await pbkfd(cle)\r\n  console.log(u8ToB64(clebin, true))\r\n  const clebin2 = await wcrypt.pbkfd(cle)\r\n  const s1 = u8ToB64(clebin2, true)\r\n  let u8 = b64ToU8(s1)\r\n  const s2 = u8ToB64(clebin2, false)\r\n  console.log(s1)\r\n  console.log(s2)\r\n  u8 = b64ToU8(s1)\r\n  const s3 = u8ToB64(u8, false)\r\n  console.log(s3)\r\n\r\n  cle = enc.encode('toto est beau')\r\n  clebin = await wcrypt.sha256(cle)\r\n  const cle64 = u8ToB64(clebin, true)\r\n\r\n  const sha1 = await sha256(cle)\r\n  const sha2 = await wcrypt.sha256(cle)\r\n  console.log(u8ToB64(sha1, true))\r\n  console.log(u8ToB64(sha2, true))\r\n\r\n  let x = wcrypt.random(16)\r\n  console.log(u8ToB64(x, true))\r\n  x = wcrypt.random(6)\r\n\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  x = enc.encode(xx)\r\n  const e1 = await crypter(clebin, x)\r\n  console.log(e1.toString('hex'))\r\n  const d1 = await wcrypt.decrypter(clebin, e1)\r\n  console.log(dec.decode(d1))\r\n  const n = Number(crypto.randomBytes(1)[0])\r\n  const e2 = await wcrypt.crypter(cle64, x, n)\r\n  console.log(e2.toString('hex'))\r\n  const d2 = await decrypter(clebin, e2)\r\n  console.log(dec.decode(d2))\r\n  const e3 = await crypter(cle64, x, n)\r\n  console.log(e3.toString('hex'))\r\n  const d3 = await wcrypt.decrypter(clebin, e3)\r\n  console.log(dec.decode(d3))\r\n\r\n  const kp = await wcrypt.genKeyPair()\r\n  const encRSA1 = await crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA1 : ' + u8ToB64(encRSA1))\r\n  const encRSA2 = await wcrypt.crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA2 : ' + u8ToB64(encRSA2))\r\n\r\n  const decRSA1 = await decrypterRSA(kp.privateKey, encRSA1)\r\n  console.log('decypted data RSA2 : ' + dec.decode(decRSA1))\r\n  const decRSA2 = await wcrypt.decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA2))\r\n\r\n  const decRSA2b = await decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA2 : ' + dec.decode(decRSA2b))\r\n  const decRSA1b = await wcrypt.decrypterRSA(kp.privateKey, encRSA1)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA1b))\r\n}\r\n*/\n\n//# sourceURL=webpack://boitessrv/./src/webcrypto.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server.mjs");
/******/ 	
/******/ })()
;