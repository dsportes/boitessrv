/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("module");

/***/ }),

/***/ "./src/api.mjs":
/*!*********************!*\
  !*** ./src/api.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"PINGTO\": () => (/* binding */ PINGTO),\n/* harmony export */   \"E_BRK\": () => (/* binding */ E_BRK),\n/* harmony export */   \"E_WS\": () => (/* binding */ E_WS),\n/* harmony export */   \"E_DB\": () => (/* binding */ E_DB),\n/* harmony export */   \"E_BRO\": () => (/* binding */ E_BRO),\n/* harmony export */   \"E_SRV\": () => (/* binding */ E_SRV),\n/* harmony export */   \"X_SRV\": () => (/* binding */ X_SRV),\n/* harmony export */   \"F_BRO\": () => (/* binding */ F_BRO),\n/* harmony export */   \"F_SRV\": () => (/* binding */ F_SRV),\n/* harmony export */   \"AppExc\": () => (/* binding */ AppExc),\n/* harmony export */   \"INDEXT\": () => (/* binding */ INDEXT),\n/* harmony export */   \"argTypes\": () => (/* binding */ argTypes)\n/* harmony export */ });\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n/* harmony import */ var _rowTypes_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rowTypes.mjs */ \"./src/rowTypes.mjs\");\n\r\n\r\n\r\nconst version = '1'\r\n\r\nconst PINGTO = 10000 // en secondes\r\n\r\nconst E_BRK = -1 // Interruption volontaire de l'opération\r\nconst E_WS = -2 // Toutes erreurs de réseau\r\nconst E_DB = -3 // Toutes erreurs d'accès à la base locale\r\nconst E_BRO = -4 // Erreur inattendue trappée sur le browser\r\nconst E_SRV = -5 // Erreur inattendue trappée sur le serveur\r\nconst X_SRV = -6 // Erreur fonctionnelle trappée sur le serveur transmise en exception\r\nconst F_BRO = -7 // Erreur fonctionnelle trappée sur le browser\r\nconst F_SRV = -8 // Erreur fonctionnelle trappée sur le serveur transmise en résultat\r\n\r\nclass AppExc {\r\n  constructor (code, message, stack) {\r\n    this.code = code\r\n    this.message = message || '?'\r\n    if (stack) this.stack = stack\r\n  }\r\n\r\n  toString () {\r\n    return JSON.stringify(this)\r\n  }\r\n}\r\n\r\nconst INDEXT = {\r\n  SECRET: 0,\r\n  INVITGR: 1,\r\n  AVATAR: 2,\r\n  CONTACT: 3,\r\n  INVITCT: 4,\r\n  RENCONTRE: 5,\r\n  PARRAIN: 6,\r\n  GROUPE: 1,\r\n  MEMBRE: 2\r\n}\r\n\r\nconst arrayIntType = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({ type: 'array', items: 'int' })\r\nconst arrayLongType = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({ type: 'array', items: 'long' })\r\nconst mapIntType = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({ type: 'map', values: 'int' })\r\n\r\nconst rowItem = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowitem',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'table', type: 'string' },\r\n    { name: 'id', type: 'string' },\r\n    { name: 'serial', type: ['null', 'bytes'], default: null }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'synclist',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'dh', type: 'long' },\r\n    { name: 'rowItems', type: ['null', { type: 'array', items: [rowItem] }], default: null }\r\n  ]\r\n})\r\n\r\nconst echoArg = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'echo',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'a', type: 'int' },\r\n    { name: 'b', type: 'string' },\r\n    { name: 'to', type: 'int' },\r\n    { name: 'org', type: ['null', 'string'], default: null }\r\n  ]\r\n})\r\n\r\nconst echoResp = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'echoResp',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'a', type: 'int' },\r\n    { name: 'b', type: 'string' },\r\n    { name: 'org', type: ['null', 'string'] }\r\n  ]\r\n})\r\n\r\nconst connexionCompte = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'connexionCompte',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'pcbh', type: 'long' },\r\n    { name: 'dpbh', type: 'long' }\r\n  ]\r\n})\r\n\r\nconst respBase1 = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'respBase1',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'dh', type: 'long' },\r\n    { name: 'rowItems', type: ['null', { type: 'array', items: [rowItem] }], default: null }\r\n  ]\r\n})\r\n\r\nconst creationCompte = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'creationCompte',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'mdp64', type: 'string' },\r\n    { name: 'q1', type: 'int' },\r\n    { name: 'q2', type: 'int' },\r\n    { name: 'qm1', type: 'int' },\r\n    { name: 'qm2', type: 'int' },\r\n    { name: 'clePub', type: 'string' },\r\n    { name: 'rowCompte', type: 'bytes' },\r\n    { name: 'rowAvatar', type: 'bytes' }\r\n  ]\r\n})\r\n\r\nconst sync1 = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'sync1',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'lvav', type: mapIntType }\r\n  ]\r\n})\r\n\r\nconst sync2 = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'sync2',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'idc', type: 'long' },\r\n    { name: 'lav', type: arrayLongType },\r\n    { name: 'lgr', type: arrayLongType }\r\n  ]\r\n})\r\n\r\nconst sync3 = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'sync3',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'avgr', type: 'long' },\r\n    { name: 'lv', type: arrayIntType }\r\n  ]\r\n})\r\n\r\nconst sync4 = _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'sync3',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'vcv', type: 'int' },\r\n    { name: 'lcvmaj', type: arrayIntType },\r\n    { name: 'lcvchargt', type: arrayIntType }\r\n  ]\r\n})\r\n\r\nconst argTypes = {\r\n  echo: [echoArg, echoResp],\r\n  creationCompte: [creationCompte, respBase1],\r\n  connexionCompte: [connexionCompte, respBase1],\r\n  syncInvitgr: [sync1, respBase1],\r\n  syncAbo: [sync2, respBase1],\r\n  syncAv: [sync3, respBase1],\r\n  syncGr: [sync3, respBase1],\r\n  chargtCVs: [sync4, respBase1]\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/api.mjs?");

/***/ }),

/***/ "./src/crypto.mjs":
/*!************************!*\
  !*** ./src/crypto.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crypt\": () => (/* binding */ crypt)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.mjs */ \"./src/webcrypto.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/crypto.mjs\")\r\n\r\n;\r\nconst base64js = require('base64-js')\r\n\r\nconst crypt = { pbkfd: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.pbkfd, sha256: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.sha256, random: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.random, crypter: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypter, decrypter: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypter, decrypterStr: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypterStr, genKeyPair: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.genKeyPair, crypterRSA: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypterRSA, decrypterRSA: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.decrypterRSA, concat: _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.concat, u8ToB64, b64ToU8, rnd6, hash, hashBin, int2base64, bigToU8, u8ToBig, u8ToInt, intToU8, sidToId, idToSid, test }\r\n\r\nfunction u8ToB64 (u8, url) {\r\n  const s = base64js.fromByteArray(u8)\r\n  if (!url) return s\r\n  return s.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\r\n}\r\n\r\nfunction b64ToU8 (s) {\r\n  const diff = s.length % 4\r\n  let x = s\r\n  if (diff) {\r\n    const pad = '===='.substring(0, 4 - diff)\r\n    x = s + pad\r\n  }\r\n  return base64js.toByteArray(x.replace(/-/g, '+').replace(/_/g, '/'))\r\n}\r\n\r\nfunction rnd6 () { return u8ToInt((0,_webcrypto_mjs__WEBPACK_IMPORTED_MODULE_1__.random)(6)) }\r\n\r\nfunction hash (str, big = false, b64 = false, seed = 0) {\r\n  // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\r\n  for (let i = 0, ch; i < str.length; i++) {\r\n    ch = str.charCodeAt(i)\r\n    h1 = Math.imul(h1 ^ ch, 2654435761)\r\n    h2 = Math.imul(h2 ^ ch, 1597334677)\r\n  }\r\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909)\r\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909)\r\n  const r = big ? 4294967296n * BigInt(h2) + BigInt(h1) : 4294967296 * (2097151 & h2) + (h1 >>> 0)\r\n  if (Number.isSafeInteger(r)) {\r\n    console.log(r)\r\n  }\r\n  return b64 ? int2base64(r) : r\r\n}\r\n\r\nfunction hashBin (str, big = false, b64 = false, seed = 0) {\r\n  // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed\r\n  for (let i = 0, ch; i < str.length; i++) {\r\n    ch = str[i]\r\n    h1 = Math.imul(h1 ^ ch, 2654435761)\r\n    h2 = Math.imul(h2 ^ ch, 1597334677)\r\n  }\r\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909)\r\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909)\r\n  const r = big ? 4294967296n * BigInt(h2) + BigInt(h1) : 4294967296 * (2097151 & h2) + (h1 >>> 0)\r\n  return b64 ? int2base64(r) : r\r\n}\r\n\r\nconst c64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\r\nfunction int2base64 (n) {\r\n  let r = '', x = n, i\r\n  const b = typeof n !== 'number'\r\n  while (x) {\r\n    i = b ? Number(x % 64n) : x % 64\r\n    r += c64.charAt(i < 0 ? -i : i)\r\n    x = b ? x / 64n : Math.floor(x / 64)\r\n  }\r\n  return r\r\n}\r\n\r\nfunction writeUInt32LE (u8, value, offset) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  u8[offset + 3] = (value >>> 24)\r\n  u8[offset + 2] = (value >>> 16)\r\n  u8[offset + 1] = (value >>> 8)\r\n  u8[offset] = (value & 0xff)\r\n  return offset + 4\r\n}\r\n\r\nconst max32 = BigInt(2 ** 32)\r\nfunction bigToU8 (n) {\r\n  if (typeof n === 'number') n = BigInt(n)\r\n  if (n < 0) n = -n\r\n  const buf = new Uint8Array(8)\r\n  writeUInt32LE(buf, Number(n / max32), 4)\r\n  writeUInt32LE(buf, Number(n % max32), 0)\r\n  return buf\r\n}\r\n\r\nfunction readUInt32LE (u8, offset) {\r\n  offset = offset >>> 0\r\n  return ((u8[offset]) |\r\n      (u8[offset + 1] << 8) |\r\n      (u8[offset + 2] << 16)) +\r\n      (u8[offset + 3] * 0x1000000)\r\n}\r\n\r\nconst BI_MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\r\nfunction u8ToBig (u8, number = false) {\r\n  const fort = BigInt(readUInt32LE(u8, 4))\r\n  const faible = BigInt(readUInt32LE(u8, 0))\r\n  const r = (fort * max32) + faible\r\n  return number && r < BI_MAX_SAFE_INTEGER ? Number(r) : r\r\n}\r\n\r\nfunction u8ToInt (u8) {\r\n  if (!u8 || !u8.length || u8.length > 8) return 0\r\n  let r = 0n\r\n  for (let i = u8.length - 1; i > 0; i--) {\r\n    r += BigInt(u8[i]) * (p2b[i - 1] + 1n)\r\n  }\r\n  r += BigInt(u8[0])\r\n  return r > BI_MAX_SAFE_INTEGER ? r : Number(r)\r\n}\r\n\r\nconst p2 = [255, (256 ** 2) - 1, (256 ** 3) - 1, (256 ** 4) - 1, (256 ** 5) - 1, (256 ** 6) - 1, (256 ** 7) - 1]\r\nconst p2b = [255n, (256n ** 2n) - 1n, (256n ** 3n) - 1n, (256n ** 4n) - 1n, (256n ** 5n) - 1n, (256n ** 6n) - 1n, (256n ** 7n) - 1n]\r\nfunction intToU8 (n) {\r\n  const bi = typeof n === 'bigint'\r\n  if (n < 0) n = -n\r\n  const p2x = bi ? p2b : p2\r\n  let l = 8\r\n  for (let i = 6; i >= 0; i--, l--) if (n > p2x[i]) break\r\n  const u8 = new Uint8Array(l)\r\n  for (let i = 0; i < 8; i++) {\r\n    u8[i] = bi ? Number(n % 256n) : n % 256\r\n    n = bi ? (n / 256n) : Math.floor(n / 256)\r\n  }\r\n  return u8\r\n}\r\n\r\nfunction sidToId (id) {\r\n  return u8ToInt(b64ToU8(id, true)) // b64 -> buffer\r\n}\r\n\r\nfunction idToSid (id) { // to string (b64)\r\n  if (typeof id === 'string') return id // déjà en B64\r\n  if (typeof id === 'number') return u8ToB64(intToU8(id), true) // int -> u8 -> b64\r\n  return u8ToB64(id, true) // u8 -> b64\r\n}\r\n\r\nasync function test () { }\r\n\r\n/*\r\nasync function test () {\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  console.log(int2base64(12345678))\r\n  console.log(int2base64(12345678n))\r\n  console.log(hash(xx, false, false))\r\n  console.log(hash(xx, false, true))\r\n  console.log(hash(xx, true, false))\r\n  console.log(hash(xx, true, true))\r\n  let z = hash(xx, false)\r\n  console.log(z)\r\n  const b1 = bigToU8(z)\r\n  console.log(u8ToB64(b1, true))\r\n  console.log(u8ToBig(b1))\r\n  z = hash(xx, true)\r\n  console.log(z)\r\n  const b2 = bigToU8(z)\r\n  console.log(u8ToB64(b2, true))\r\n  console.log(u8ToBig(b2, true))\r\n  console.log(u8ToBig(b2))\r\n  console.log(b1.length + ' - ' + b2.length)\r\n\r\n  const m7 = (2n ** 64n) - 1n\r\n  const m5 = p2[4] + 10\r\n  const m5b = p2b[4] + 10n\r\n  const m1 = 10\r\n  let u7, v7, i7, j7\r\n  const t1 = new Date().getTime()\r\n  for (let i = 0; i < 1000; i++) {\r\n    u7 = intToU8(m7)\r\n    i7 = u8ToInt(u7)\r\n  }\r\n  const t2 = new Date().getTime()\r\n  console.log((t2 - t1) + 'ms')\r\n  for (let i = 0; i < 1000; i++) {\r\n    v7 = bigToU8(m7)\r\n    j7 = u8ToBig(v7)\r\n  }\r\n  const t3 = new Date().getTime()\r\n  console.log((t3 - t2) + 'ms')\r\n  console.log('u7 ' + hashBin(u7))\r\n  console.log('v7 ' + hashBin(v7))\r\n\r\n  const u5 = intToU8(m5)\r\n  const v5 = bigToU8(m5b)\r\n  const i5 = u8ToInt(u5)\r\n  const j5 = u8ToBig(v5)\r\n  console.log('u5 ' + hashBin(u5))\r\n  console.log('v5 ' + hashBin(v5))\r\n\r\n  const u1 = intToU8(m1)\r\n  const v1 = bigToU8(10n)\r\n  const i1 = u8ToInt(u1)\r\n  const j1 = u8ToBig(v1)\r\n  console.log('u1 ' + hashBin(u1))\r\n  console.log('v1 ' + hashBin(v1))\r\n\r\n  console.log(m7 + ' ' + u7.toString('hex') + ' ' + v7.toString('hex') + ' ' + i7 + ' ' + j7)\r\n  console.log(m5 + ' ' + u5.toString('hex') + ' ' + v5.toString('hex') + ' ' + i5 + ' ' + j5)\r\n  console.log(m1 + ' ' + u1.toString('hex') + ' ' + v1.toString('hex') + ' ' + i1 + ' ' + j1)\r\n}\r\nexports.test = test\r\n\r\nasync function testWAC () {\r\n  const enc = new TextEncoder()\r\n  const dec = new TextDecoder()\r\n\r\n  let cle = 'toto est beau'\r\n  const clebin2 = await wcrypt.pbkfd(cle)\r\n  const s1 = u8ToB64(clebin2, true)\r\n  let u8 = b64ToU8(s1)\r\n  const s2 = u8ToB64(clebin2, false)\r\n  console.log(s1)\r\n  console.log(s2)\r\n  u8 = b64ToU8(s1)\r\n  const s3 = u8ToB64(u8, false)\r\n  console.log(s3)\r\n\r\n  cle = enc.encode('toto est beau')\r\n  const clebin = wcrypt.sha256(cle)\r\n  const cle64 = u8ToB64(clebin, true)\r\n\r\n  const sha2 = wcrypt.sha256(cle)\r\n  console.log(u8ToB64(sha2, true))\r\n\r\n  let x = wcrypt.random(16)\r\n  console.log(u8ToB64(x, true))\r\n  x = wcrypt.random(6)\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  x = enc.encode(xx)\r\n  const e1 = Buffer.from(await wcrypt.crypter(clebin, x))\r\n  console.log(e1.toString('hex'))\r\n  const d1 = await wcrypt.decrypter(clebin, e1)\r\n  console.log(dec.decode(d1))\r\n  const n = Number(wcrypt.random(1)[0])\r\n  const e2 = await wcrypt.crypter(cle64, x, n)\r\n  console.log(e2.toString('hex'))\r\n  const d2 = await wcrypt.decrypter(clebin, e2)\r\n  console.log(dec.decode(d2))\r\n  const e3 = await wcrypt.crypter(cle64, x, n)\r\n  console.log(e3.toString('hex'))\r\n  const d3 = await wcrypt.decrypter(clebin, e3)\r\n  console.log(dec.decode(d3))\r\n\r\n  const kp = await wcrypt.genKeyPair()\r\n  const encRSA2 = await wcrypt.crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA2 : ' + u8ToB64(encRSA2))\r\n  const decRSA2 = await wcrypt.decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA2))\r\n}\r\nexports.testWAC = testWAC\r\n\r\nasync function testAvro () {\r\n  const enc = new TextEncoder()\r\n  const dec = new TextDecoder()\r\n  const avro = require('avsc')\r\n  const cle = wcrypt.sha256(enc.encode('toto est beau'))\r\n  const txt = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  const bin = await wcrypt.crypter(cle, enc.encode(txt))\r\n  const bin2 = Buffer.from(bin)\r\n  const itemType = avro.Type.forSchema({\r\n    name: 'item',\r\n    type: 'record',\r\n    fields: [\r\n      { name: 'txt', type: 'string' },\r\n      { name: 'bin', type: 'bytes' }\r\n    ]\r\n  })\r\n  const item = { txt, bin: bin2 }\r\n  const buf = itemType.toBuffer(item)\r\n  const item2 = itemType.fromBuffer(buf)\r\n  const b = await wcrypt.decrypter(cle, item2.bin)\r\n  console.log(dec.decode(b))\r\n}\r\nexports.testAvro = testAvro\r\n*/\r\n\n\n//# sourceURL=webpack://boitessrv/./src/crypto.mjs?");

/***/ }),

/***/ "./src/m1.mjs":
/*!********************!*\
  !*** ./src/m1.mjs ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"m1fonctions\": () => (/* binding */ m1fonctions)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto.mjs */ \"./src/crypto.mjs\");\n/* harmony import */ var _session_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./session.mjs */ \"./src/session.mjs\");\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/m1.mjs\")\r\n\r\n;\r\n\r\nconst now = require('nano-time')\r\n;\r\n\r\n\r\nconst VERSIONS = 1\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nconst dev = \"development\" === 'development'\r\nconst nbVersions = 100\r\nconst defautVersions = new Array(nbVersions)\r\nfor (let i = 0; i < nbVersions; i++) { defautVersions[i] = 0 }\r\n\r\nconst valueTypes = {\r\n  0: { type: 'json', defaut: '{}' },\r\n  1: { type: _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.forSchema({ type: 'array', items: 'int' }), defaut: defautVersions }\r\n}\r\n\r\nfunction sleep (delai) {\r\n  if (delai <= 0) return\r\n  return new Promise((resolve) => { setTimeout(() => resolve(), delai) })\r\n}\r\n\r\nconst m1fonctions = { }\r\n\r\n/*\r\nInitialisation du module APRES que le serveur ait été créé et soit opérationnel\r\nRafraîchissement périodique en cache (si demandé et seulement pour la production) de la liste des aricles à peser\r\nafin que les balances aient plus rapidement la réponse en cas de changement dans Odoo\r\n*/\r\nfunction atStart(/* cfg */) {\r\n  console.log('m1 start')\r\n}\r\nm1fonctions.atStart = atStart\r\n\r\n/***************************************************************\r\nAppel de l'opération\r\n    cfg : configuration relative au code de l'organisation    \r\n    args : objet des arguments\r\nRetourne un objet result :node -version\r\n\r\n    result.type : type mime\r\n    result.bytes : si le résultat est du binaire\r\nPour un POST :\r\n    OK : result : objet résultat à sérialiser - HTTP status 200\r\n\r\nException : \r\n    AppExc : AppExc sérialisé en JSON\r\n        code F_SRV - erreur fonctionnelle à retourner par l'application\r\n            HTTP status 400\r\n        code X_SRV - erreur fonctionnelle à émettre en exception à l'application\r\n            HTTP status 401                   \r\n    Non transformée en AppExc : Création d'un AppExc avec E_SRV sérialisé en JSON\r\n        HTTP status 402\r\n*****************************************************************/\r\n\r\nasync function echo (cfg, args, isGet) {\r\n  if (args.to) {\r\n    await sleep(args.to * 1000)\r\n  }\r\n  if (!args) args = { a: 1, b: 'toto' }\r\n  args.org = cfg.code || 'org'\r\n  return !isGet ? args : { type:'text/plain', bytes:Buffer.from(JSON.stringify(args), 'utf8') }\r\n}\r\nm1fonctions.echo = echo\r\n\r\nasync function erreur (cfg, args) {\r\n  if (args.to) {\r\n    await sleep(args.to * 1000)\r\n  }\r\n  throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(args.code, args.message)\r\n}\r\nm1fonctions.erreur = erreur\r\n\r\nasync function pingdb (cfg) {\r\n  stmt(cfg, selvalues).get({ id: 1 })\r\n  return { dhc: getdhc() }\r\n}\r\nm1fonctions.pingdb = pingdb\r\n\r\n/*\r\nfunction decryptDatax(cle, datax) {\r\n    const x = crypt.decrypter(cle, Buffer.from(datax, 'base64'))\r\n    const y = x.toString('utf8')\r\n    return JSON.parse(y)\r\n}\r\n\r\nfunction cryptDatax(cle, datax) {\r\n    const j = JSON.stringify(datax)\r\n    return [j, base64url(crypt.crypter(cle, Buffer.from(j, 'utf8')))]\r\n}\r\n*/\r\n\r\nfunction getdhc() {\r\n  return parseInt(now.micro(), 10)\r\n}\r\n\r\nclass Dds {\r\n  constructor () {\r\n    this.j0 = Math.floor(new Date('2020-01-01T00:00:00').getTime() / 86400000)\r\n  }\r\n  \r\n  // jour courant (nombre de jours écoulés) depuis le 1/1/2020\r\n  jourJ () {\r\n    return Math.floor(new Date().getTime() / 86400000) - this.j0\r\n  }\r\n\r\n  /* \r\n  Si la dds actuelle du compte n'a pas plus de 28 jours, elle convient encore.\r\n  Sinon il faut en réattribuer une qui ait entre 14 et 28 jours d'âge.\r\n  */\r\n  ddsc (dds) {\r\n    const j = this.jourJ()\r\n    return ((j - dds) > 28) ? j - 14 - Math.floor(Math.random() * 14) : dds\r\n  }\r\n\r\n  /* \r\n  Si la dds actuelle de l'avatar ou du groupe n'a pas plus de 14 jours, elle convient encore.\r\n  Sinon il faut en réattribuer une qui ait entre 0 et 14 d'âge.\r\n  */\r\n  ddsag (dds) {\r\n    const j = this.jourJ()\r\n    return ((j - dds) > 14) ? j - Math.floor(Math.random() * 14) : dds\r\n  }\r\n}\r\nconst dds = new Dds()\r\n\r\n/* Mois courant depuis janvier 2020 */\r\n// eslint-disable-next-line no-unused-vars\r\nfunction getMois () {\r\n  const d = new Date()\r\n  const an = (d.getUTCFullYear() % 100) - 20\r\n  const mo = d.getUTCMonth()\r\n  return ( (an * 12) + mo)\r\n}\r\n\r\n/******************************************/\r\nconst cachestmt = { }\r\n\r\nfunction stmt (cfg, sql) {\r\n  let c = cachestmt[cfg.code]\r\n  if (!c) { c = {}; cachestmt[cfg.code] = c }\r\n  if (!c[sql])\r\n    try {\r\n      c[sql] = cfg.db.prepare(sql)\r\n    } catch (e) {\r\n      console.log(e.toString())\r\n    }\r\n  return c[sql]\r\n}\r\n\r\n/******************************************/\r\nconst selvalues = 'SELECT v FROM versions WHERE id = @id'\r\nconst insvalues = 'INSERT INTO versions (id, v) VALUES (@id, @v)'\r\nconst updvalues = 'UPDATE versions SET v = @v WHERE id = @id'\r\n\r\nconst cacheValues = { }\r\n\r\nfunction getValue (cfg, n) {\r\n  let cache = cacheValues[cfg.code]\r\n  if (!cache) {\r\n    cache = {}\r\n    cacheValues[cfg.code] = cache\r\n  }\r\n  if (cache[n]) return cache[n]\r\n  const t = valueTypes[n]\r\n  let value\r\n  const res = stmt(cfg, selvalues).get({ id: n })\r\n  let bin = res ? res.v : null\r\n  if (bin) {\r\n    value = t.type === 'json' ? JSON.parse(Buffer.from(bin).toString()) : t.type.fromBuffer(bin)\r\n  } else {\r\n    value = t.defaut\r\n    bin = t.type === 'json' ? Buffer.from(value) : t.type.toBuffer(value)\r\n    stmt(cfg, insvalues).run({ id: n, v: bin })\r\n  }\r\n  cache[n] = value\r\n  return value\r\n}\r\n\r\nfunction setValue (cfg, n) {\r\n  const t = valueTypes[n]\r\n  const value = cacheValues[cfg.code][n]\r\n  const bin = t.type === 'json' ? Buffer.from(value) : t.type.toBuffer(value)\r\n  stmt(cfg, updvalues).run({ id: n, v: bin })\r\n}\r\n\r\n/******************************************/\r\nfunction newItem (table, row) {\r\n  const item = { table: table }\r\n  if (row.id) item.id = _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.idToSid(row.id)\r\n  item.serial = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.serialize('row' + table, row)\r\n  return item\r\n}\r\n\r\n/******************************************/\r\nconst inscompte = 'INSERT INTO compte (id, v, dds, dpbh, pcbh, kx, mack, mmck, memok) VALUES (@id, @v, @dds, @dpbh, @pcbh, @kx, @mack, @mmck, @memok)'\r\nconst insavatar = 'INSERT INTO avatar (id, v, st, vcv, dds, cva, lctk) VALUES (@id, @v, @st, @vcv, @dds, @cva, @lctk)'\r\nconst insavrsa = 'INSERT INTO avrsa (id, clepub) VALUES (@id, @clepub)'\r\nconst insavgrvq = 'INSERT INTO avgrvq (id, q1, q2, qm1, qm2, v1, v2, vm1, vm2) VALUES (@id, @q1, @q2, @qm1, @qm2, @v1, @v2, @vm1, @vm2)'\r\nconst selcomptedpbh = 'SELECT * FROM compte WHERE dpbh = @dpbh'\r\n\r\nfunction idx (id) {\r\n  return (id % (nbVersions - 1)) + 1\r\n}\r\n\r\n/* Creation de compte sans parrain\r\nargs: \r\n  name: 'creationCompte',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'mdp64', type: 'string' },\r\n    { name: 'dpbh', type: 'long' },\r\n    { name: 'q1', type: 'int' },\r\n    { name: 'q2', type: 'int' },\r\n    { name: 'qm1', type: 'int' },\r\n    { name: 'qm2', type: 'int' },\r\n    { name: 'clePub', type: 'bytes' },\r\n    { name: 'rowCompte', type: 'bytes' },\r\n    { name: 'rowAvatar', type: 'bytes' }\r\n  ]\r\nRetour :\r\n  name: 'respBase1',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'status', type: 'int' },\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'dh', type: 'long' },\r\n    { name: 'rows', type: { type: 'array', items: ['bytes'] } }\r\n  ]\r\n*/\r\nfunction creationCompte (cfg, args) {  \r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  if (cfg.cle !== args.mdp64) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Mot de passe de l\\'organisation non reconnu. Pour créer un compte privilégié, le mot de passe de l\\'organisation est requis')\r\n  }\r\n  const session = (0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.getSession)(args.sessionId)\r\n  const compte = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowcompte', args.rowCompte)\r\n  const avatar = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.deserialize('rowavatar', args.rowAvatar)\r\n\r\n  const versions = getValue(cfg, VERSIONS)\r\n  let j = idx(compte.id)\r\n  versions[j]++\r\n  compte.v = versions[j]\r\n  j = idx(avatar.id)\r\n  versions[j]++\r\n  avatar.v = versions[j]\r\n  setValue(cfg, VERSIONS)\r\n\r\n  compte.dds = dds.ddsc(compte.dds)\r\n  avatar.dds = dds.ddsag(avatar.dds)\r\n  const avrsa = { id: avatar.id, clepub: args.clePub }\r\n  const avgrvq = { id: avatar.id, q1: args.q1, q2: args.q2, qm1: args.qm1, qm2:args.qm2, v1: 0, v2:0, vm1:0, vm2: 0 }\r\n\r\n  cfg.db.transaction(creationCompteTr)(cfg, session, compte, avatar, avrsa, avgrvq)\r\n\r\n  result.rowItems = [ newItem('compte', compte), newItem('avatar', avatar) ]    \r\n  return result\r\n}\r\nm1fonctions.creationCompte = creationCompte\r\n\r\nfunction creationCompteTr (cfg, session, compte, avatar, avrsa, avgrvq) {\r\n  const c = stmt(cfg, selcomptedpbh).get({ dpbh: compte.dpbh })\r\n  if (c) {\r\n    if (c.pcbh === compte.pcbh) {\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Phrase secrète probablement déjà utilisée. Vérifier que le compte n\\'existe pas déjà en essayant de s\\'y connecter avec la phrase secrète')\r\n    } else {\r\n      throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Une phrase secrète semblable est déjà utilisée. Changer a minima la première ligne de la phrase secrète pour ce nouveau compte')\r\n    }\r\n  }\r\n  const c1 = { ...compte }\r\n  const a1 = { ...avatar }\r\n  stmt(cfg, inscompte).run(c1)\r\n  stmt(cfg, insavatar).run(a1)\r\n  stmt(cfg, insavrsa).run(avrsa)\r\n  stmt(cfg, insavgrvq).run(avgrvq)\r\n  session.compteId = compte.id\r\n  session.avatarsId = [avatar.id]\r\n}\r\n\r\n/******************************************\r\nDétermine si les hash de la phrase secrète en argument correspond à un compte.\r\nargs = { dpbh, pcbh }\r\nRetour = compte\r\n*/\r\nasync function connexionCompte (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const c = stmt(cfg, selcomptedpbh).get({ dpbh: args.dpbh })\r\n  if (!c || (c.pcbh !== args.pcbh)) {\r\n    throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV, 'Compte non authentifié : aucun compte n\\'est déclaré avec cette phrase secrète')\r\n  }\r\n  const it = newItem('compte', c)\r\n  result.rowItems = [ it ]\r\n  return result\r\n}\r\nm1fonctions.connexionCompte = connexionCompte\r\n\r\n/*****************************************\r\nChargement des rows d'un avatar \r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'avgr', type: 'long' },\r\n    { name: 'lv', type: arrayIntType } 7 compteurs pour les versions des 7 tables\r\n*/\r\n\r\nconst selsecret = 'SELECT * FROM secret WHERE id = @id AND v > @v'\r\nconst selinvitgr = 'SELECT * FROM invitgr WHERE id = @id AND v > @v'\r\nconst selavatar = 'SELECT * FROM avatar WHERE id = @id AND v > @v'\r\nconst selcontact = 'SELECT * FROM contact WHERE id = @id AND v > @v'\r\nconst selinvitct = 'SELECT * FROM invitct WHERE id = @id AND v > @v'\r\nconst selrencontre = 'SELECT * FROM rencontre WHERE id = @id AND v > @v'\r\nconst selparrain = 'SELECT * FROM parrain WHERE id = @id AND v > @v'\r\nconst selgroupe = 'SELECT * FROM groupe WHERE id = @id AND v > @v'\r\nconst selmembre = 'SELECT * FROM membre WHERE id = @id AND v > @v'\r\n\r\nasync function syncAv (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const rowItems = []\r\n  const id = args.avgr\r\n  let rows\r\n  /*\r\n  rows = stmt(cfg, selinvitgr).all({ id, v: args.lv[INDEXT.INVITGR] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('invitgr', row))\r\n  })\r\n  */\r\n  rows = stmt(cfg, selavatar).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.AVATAR] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('avatar', row))\r\n  })\r\n  rows = stmt(cfg, selcontact).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.CONTACT] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('contact', row))\r\n  })\r\n  rows = stmt(cfg, selinvitct).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.INVITCT] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('invitvt', row))\r\n  })\r\n  rows = stmt(cfg, selrencontre).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.RENCONTRE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('rencontre', row))\r\n  })\r\n  rows = stmt(cfg, selparrain).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.PARRAIN] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('parrain', row))\r\n  })\r\n  rows = stmt(cfg, selsecret).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.SECRET] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('secret', row))\r\n  })\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.syncAv = syncAv\r\n\r\n/*****************************************/\r\nasync function syncGr (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const rowItems = []\r\n  const id = args.avgr\r\n  let rows = stmt(cfg, selgroupe).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.GROUPE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('groupe', row))\r\n  })\r\n  rows = stmt(cfg, selmembre).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.MEMBRE] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('membre', row))\r\n  })\r\n  rows = stmt(cfg, selsecret).all({ id, v: args.lv[_api_mjs__WEBPACK_IMPORTED_MODULE_3__.INDEXT.SECRET] })\r\n  rows.forEach((row) => {\r\n    rowItems.push(newItem('secret', row))\r\n  })\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.syncGr = syncGr\r\n\r\n/*****************************************\r\nChargement des rows invitgr de la liste fournie\r\n{ name: 'sessionId', type: 'string' },\r\n{ name: 'lvav', type: mapIntType } key: sid de l'avatar, value: version\r\n*/\r\nasync function syncInvitgr (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const rowItems = []\r\n  for(const sid in args.lvav) {\r\n    const v = args.lvav[sid]\r\n    const id = _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.sidToId(sid)\r\n    const rows = stmt(cfg, selinvitgr).all({ id, v })\r\n    rows.forEach((row) => {\r\n      rowItems.push(newItem('invitgr', row))\r\n    })\r\n  }\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.syncInvitgr = syncInvitgr\r\n\r\n/******************************************\r\nAbonnement de la session aux compte et listes d'avatars et de groupes et signatures\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'idc', type: 'long' },\r\n    { name: 'lav', type: arrayLongType },\r\n    { name: 'lgr', type: arrayLongType }\r\n*/\r\nasync function syncAbo (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const session = (0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.getSession)(args.sessionId)\r\n  if (args.idc) session.compteId = args.idc\r\n  session.avatarsIds = args.lav\r\n  session.groupesIds = args.lgr\r\n\r\n  if (args.idc) {\r\n    cfg.db.transaction(signaturesTr)(cfg, args.idc, args.lav, args.lgr)\r\n  }\r\n  return result\r\n}\r\n\r\nconst updddsc = 'UPDATE compte SET dds = @dds WHERE id = @id'\r\nconst updddsa= 'UPDATE avatar SET dds = @dds WHERE id = @id'\r\nconst updddsg = 'UPDATE groupe SET dds = @dds WHERE id = @id'\r\nconst ddsc = 'SELECT dds FROM compte WHERE id = @id'\r\nconst ddsa = 'SELECT dds FROM avatar WHERE id = @id'\r\nconst ddsg = 'SELECT dds FROM groupe WHERE id = @id'\r\n\r\nfunction signaturesTr (cfg, idc, lav, lgr) {\r\n  const a = stmt(cfg, ddsc).get({ id: idc })\r\n  const n = dds.ddsc(a)\r\n  if (a > n) stmt(cfg, updddsc).run({ id: idc, dds:a })\r\n\r\n  lav.forEach((id) => {\r\n    const a = stmt(cfg, ddsa).get({ id: id })\r\n    const n = dds.ddsag(a)\r\n    if (a > n) stmt(cfg, updddsa).run({ id: id, dds: a })\r\n  })\r\n\r\n  lgr.forEach((id) => {\r\n    const a = stmt(cfg, ddsg).get({ id: id })\r\n    const n = dds.ddsag(a)\r\n    if (a > n) stmt(cfg, updddsg).run({ id: id, dds: a })\r\n  })\r\n}\r\nm1fonctions.syncAbo = syncAbo\r\n\r\n/******************************************\r\nChargement des CVs :\r\n- celles de lcvmaj si changées après vcv\r\n- celles de lcvchargt sans filtre de version\r\nAbonnement de l'union des deux listes\r\n    { name: 'sessionId', type: 'string' },\r\n    { name: 'vcv', type: 'int' },\r\n    { name: 'lcvmaj', type: arrayIntType },\r\n    { name: 'lcvchargt', type: arrayIntType }\r\n*/\r\nconst selcv1 = 'SELECT id, vcv, st, phinf FROM avatar WHERE id IN @lid AND vcv > @vcv'\r\nconst selcv2 = 'SELECT id, vcv, st, phinf FROM avatar WHERE id IN @lid'\r\n\r\nasync function chargtCVs (cfg, args) {\r\n  const result = { sessionId: args.sessionId, dh: getdhc() }\r\n  const session = (0,_session_mjs__WEBPACK_IMPORTED_MODULE_2__.getSession)(args.sessionId)\r\n  session.cvsIds = args.lcvmaj.concat(args.lcvchargt)\r\n  const rowItems = []\r\n\r\n  let lst = []\r\n  if (args.lcvmaj.length) {\r\n    args.lcvmaj.forEach((sid) => { lst.push('' + _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.sidToId(sid)) })\r\n    const lid = '(' + lst.join(',') + ')'\r\n    for (const row of stmt(cfg, selcv1).iterate({ lid, vcv: args.vcv})) {\r\n      rowItems.push(newItem('cv', row))\r\n    }\r\n  }\r\n  \r\n  lst = []\r\n  if (args.lcvchargt.length) {\r\n    args.lcvchargt.forEach((sid) => { lst.push('' + _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.sidToId(sid)) })\r\n    const lid = '(' + lst.join(',') + ')'\r\n    for (const row of stmt(cfg, selcv2).iterate({ lid })) {\r\n      rowItems.push(newItem('cv', row))\r\n    }\r\n  }\r\n\r\n  result.rowItems = rowItems\r\n  return result\r\n}\r\nm1fonctions.chargtCVs = chargtCVs\r\n\r\n/******************************************/\r\nconst bytes0 = new Uint8Array(0)\r\nconst selcv = 'SELECT id, st, vcv, cva FROM avatar WHERE id = @id'\r\nasync function getcv (cfg, args) {\r\n  try {\r\n    const c = stmt(cfg, selcv).get({ id: _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.sidToId(args.sid) })\r\n    if (!c) return { bytes0 }\r\n    const buf = _schemas_mjs__WEBPACK_IMPORTED_MODULE_4__.schemas.serialize('rowcv', c)\r\n    return { bytes: buf }\r\n  } catch (e) {\r\n    console.log(e)\r\n    return { bytes: bytes0 }\r\n  }\r\n}\r\nm1fonctions.getcv = getcv\r\n\r\n/******************************************/\r\nconst selavrsapub = 'SELECT clepub FROM avrsa WHERE id = @id'\r\nasync function getclepub (cfg, args) {\r\n  try {\r\n    const c = stmt(cfg, selavrsapub).get({ id: _crypto_mjs__WEBPACK_IMPORTED_MODULE_1__.crypt.sidToId(args.sid) })\r\n    if (!c) return { bytes0 }\r\n    return { bytes: c.clepub }\r\n  } catch (e) {\r\n    console.log(e)\r\n    return { bytes: bytes0 }\r\n  }\r\n}\r\nm1fonctions.getclepub = getclepub\r\n\n\n//# sourceURL=webpack://boitessrv/./src/m1.mjs?");

/***/ }),

/***/ "./src/rowTypes.mjs":
/*!**************************!*\
  !*** ./src/rowTypes.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n\r\n\r\n/*\r\n- `versions` (id) : table des prochains numéros de versions (actuel et dernière sauvegarde) et autres singletons clé / valeur\r\n- `avgrvq` (id) : volumes et quotas d'un avatar ou groupe\r\n- `avrsa` (id) : clé publique d'un avatar\r\n\r\n_**Tables aussi persistantes sur le client (IDB)**_\r\n\r\n- `compte` (id) : authentification et données d'un compte\r\n- `avatar` (id) : données d'un avatar et liste de ses contacts\r\n- `invitgr` (id, ni) : invitation reçue par un avatar à devenir membre d'un groupe\r\n- `contact` (id, nc) : données d'un contact d'un avatar\r\n- `invitct` (id, ni) : invitation reçue à lier un contact fort avec un autre avatar\r\n- `rencontre` (prh) id : communication par A de son nom complet à un avatar B non connu de A dans l'application\r\n- `parrain` (pph) id : parrainage par un avatar A de la création d'un nouveau compte\r\n- `groupe` (id) : données du groupe et liste de ses avatars, invités ou ayant été pressentis, un jour à être membre.\r\n- `membre` (id, im) : données d'un membre du groupe\r\n- `secret` (id, ns) : données d'un secret d'un avatar ou groupe\r\n*/\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavatar',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk\r\n    { name: 'v', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'vcv', type: 'int' },\r\n    { name: 'dds', type: 'int' },\r\n    { name: 'cva', type: 'bytes' },\r\n    { name: 'lctk', type: 'bytes' }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavgrq',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk\r\n    { name: 'q1', type: 'long' },\r\n    { name: 'q2', type: 'long' },\r\n    { name: 'qm1', type: 'long' },\r\n    { name: 'qm2', type: 'long' },\r\n    { name: 'v1', type: 'long' },\r\n    { name: 'v2', type: 'long' },\r\n    { name: 'vm1', type: 'long' },\r\n    { name: 'vm2', type: 'long' }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowavrsa',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk\r\n    { name: 'clepub', type: 'bytes' }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcompte',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk\r\n    { name: 'v', type: 'int' },\r\n    { name: 'dds', type: 'int' },\r\n    { name: 'dpbh', type: 'long' }, // index\r\n    { name: 'pcbh', type: 'long' },\r\n    { name: 'kx', type: 'bytes' },\r\n    { name: 'mack', type: 'bytes' },\r\n    { name: 'mmck', type: 'bytes' },\r\n    { name: 'memok', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcontact',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk 1\r\n    { name: 'ic', type: 'int' }, // pk 2\r\n    { name: 'v', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'q1', type: 'long' },\r\n    { name: 'q2', type: 'long' },\r\n    { name: 'qm1', type: 'long' },\r\n    { name: 'qm2', type: 'long' },\r\n    { name: 'ardc', type: 'bytes' },\r\n    { name: 'icbc', type: 'bytes' },\r\n    { name: 'vsd', type: 'int' },\r\n    { name: 'datak', type: 'bytes' }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowgroupe',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk\r\n    { name: 'v', type: 'int' },\r\n    { name: 'dds', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'cvg', type: ['null', 'bytes'] },\r\n    { name: 'mcg', type: ['null', 'bytes'] },\r\n    { name: 'lstmg', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowinvitct',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk1\r\n    { name: 'ni', type: 'int' }, // pk2\r\n    { name: 'v', type: 'int' },\r\n    { name: 'dlv', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'datap', type: ['null', 'bytes'] },\r\n    { name: 'datak', type: ['null', 'bytes'] },\r\n    { name: 'ardc', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowinvitgr',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk1\r\n    { name: 'ni', type: 'int' }, // pk2\r\n    { name: 'v', type: 'int' },\r\n    { name: 'dlv', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'datap', type: ['null', 'bytes'] },\r\n    { name: 'datak', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowmembre',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk 1\r\n    { name: 'im', type: 'int' }, // pk 2\r\n    { name: 'v', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'dlv', type: 'int' },\r\n    { name: 'vsd', type: 'int' },\r\n    { name: 'datag', type: ['null', 'bytes'] },\r\n    { name: 'ardg', type: ['null', 'bytes'] },\r\n    { name: 'lmck', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowparrain',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'pph', type: 'long' }, // pk\r\n    { name: 'id', type: 'long' },\r\n    { name: 'nc', type: 'int' },\r\n    { name: 'dlv', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'v', type: 'int' },\r\n    { name: 'q1', type: 'long' },\r\n    { name: 'q2', type: 'long' },\r\n    { name: 'qm1', type: 'long' },\r\n    { name: 'qm2', type: 'long' },\r\n    { name: 'datak', type: ['null', 'bytes'] },\r\n    { name: 'datax', type: ['null', 'bytes'] },\r\n    { name: 'ardc', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowrencontre',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'prh', type: 'long' }, // pk\r\n    { name: 'id', type: 'long' },\r\n    { name: 'v', type: 'int' },\r\n    { name: 'dlv', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'datak', type: ['null', 'bytes'] },\r\n    { name: 'nomcx', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowsecret',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' }, // pk1\r\n    { name: 'ns', type: 'int' }, // pk2\r\n    { name: 'ic', type: 'int' },\r\n    { name: 'v', type: 'int' },\r\n    { name: 'st', type: 'int' },\r\n    { name: 'txts', type: ['null', 'bytes'] },\r\n    { name: 'mcs', type: ['null', 'bytes'] },\r\n    { name: 'vsd', type: 'int' },\r\n    { name: 'aps', type: ['null', 'bytes'] },\r\n    { name: 'dups', type: ['null', 'bytes'] }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowversions',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'int' }, // pk\r\n    { name: 'v', type: 'bytes' }\r\n  ]\r\n})\r\n\r\n_schemas_mjs__WEBPACK_IMPORTED_MODULE_0__.schemas.forSchema({\r\n  name: 'rowcv',\r\n  type: 'record',\r\n  fields: [\r\n    { name: 'id', type: 'long' },\r\n    { name: 'vcv', type: 'int' },\r\n    { name: 'st', type: 'int' }, // négatif, avatar supprimé / disparu, 0:OK, 1:alerte\r\n    { name: 'phinf', type: ['null', 'bytes'], default: null }\r\n  ]\r\n})\r\n\n\n//# sourceURL=webpack://boitessrv/./src/rowTypes.mjs?");

/***/ }),

/***/ "./src/schemas.mjs":
/*!*************************!*\
  !*** ./src/schemas.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schemas\": () => (/* binding */ schemas),\n/* harmony export */   \"bigToU8\": () => (/* binding */ bigToU8),\n/* harmony export */   \"getType\": () => (/* binding */ getType)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/schemas.mjs\")\r\nconst avro = require('avsc')\r\n\r\nconst schemas = { getType, ab2b, forSchema, serialize, deserialize, test }\r\n\r\n/* Gestion Bigint **************************************************/\r\nfunction writeUInt32LE (u8, value, offset) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  u8[offset + 3] = (value >>> 24)\r\n  u8[offset + 2] = (value >>> 16)\r\n  u8[offset + 1] = (value >>> 8)\r\n  u8[offset] = (value & 0xff)\r\n  return offset + 4\r\n}\r\nconst max32 = BigInt(2 ** 32)\r\nfunction bigToU8 (n) {\r\n  if (typeof n === 'number') n = BigInt(n)\r\n  if (n < 0) n = -n\r\n  const buf = new Uint8Array(8)\r\n  writeUInt32LE(buf, Number(n / max32), 4)\r\n  writeUInt32LE(buf, Number(n % max32), 0)\r\n  return buf\r\n}\r\n\r\nfunction readUInt32LE (u8, offset) {\r\n  offset = offset >>> 0\r\n  return ((u8[offset]) |\r\n      (u8[offset + 1] << 8) |\r\n      (u8[offset + 2] << 16)) +\r\n      (u8[offset + 3] * 0x1000000)\r\n}\r\n\r\nfunction u8ToBig (u8, number = false) {\r\n  const fort = BigInt(readUInt32LE(u8, 4))\r\n  const faible = BigInt(readUInt32LE(u8, 0))\r\n  const r = (fort * max32) + faible\r\n  return !number ? r : Number(r)\r\n}\r\n\r\navro.types.LongType.__with({\r\n  fromBuffer: buf => u8ToBig(buf),\r\n  toBuffer: n => bigToU8(n < 0 ? -n : n),\r\n  fromJSON: Number,\r\n  toJSON: Number,\r\n  isValid: n => typeof n === 'bigint',\r\n  compare: (n1, n2) => n1 === n2 ? 0 : (n1 < n2 ? -1 : 1)\r\n})\r\n\r\n/* Gestion des schémas **************************************************/\r\nconst allTypes = {}\r\n\r\nfunction getType (name) {\r\n  return name && typeof name === 'string' ? allTypes[name] : null\r\n}\r\n\r\nfunction ab2b (x) {\r\n  return Buffer.from(x)\r\n}\r\n\r\nfunction forSchema (s) {\r\n  const sch = avro.Type.forSchema(s)\r\n  if (s && s.name) allTypes[s.name] = sch\r\n  return sch\r\n}\r\n\r\nfunction serialize (s, obj) {\r\n  const sch = getType(s) || s\r\n  return sch.toBuffer(obj)\r\n}\r\n\r\nfunction deserialize (s, buf) {\r\n  const sch = getType(s) || s\r\n  return sch.fromBuffer(buf)\r\n}\r\n\r\nfunction test () {\r\n  const sch = {\r\n    name: 'test',\r\n    type: 'record',\r\n    fields: [\r\n      { name: 'nom', type: 'string' },\r\n      { name: 'age', type: 'int' }\r\n    ]\r\n  }\r\n  const obj1 = { nom: 'Daniel', age: 62 }\r\n\r\n  const test1 = avro.Type.forSchema(sch)\r\n  const buf = test1.toBuffer(obj1)\r\n  const obj2 = test1.fromBuffer(buf)\r\n  console.log(JSON.stringify(obj2))\r\n\r\n  forSchema(sch)\r\n  const buf2 = serialize('test', obj1)\r\n  const obj2b = deserialize('test', buf2)\r\n  console.log(JSON.stringify(obj2b))\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/schemas.mjs?");

/***/ }),

/***/ "./src/server.mjs":
/*!************************!*\
  !*** ./src/server.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _session_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./session.mjs */ \"./src/session.mjs\");\n/* harmony import */ var _webcrypto_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webcrypto.mjs */ \"./src/webcrypto.mjs\");\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _m1_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./m1.mjs */ \"./src/m1.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/server.mjs\")\r\n\r\nconst fs = require('fs')\r\nconst http = require('http')\r\nconst https = require('https')\r\nconst process = require('process')\r\nconst path = require('path')\r\nconst express = require('express')\r\nconst WebSocket = require('ws')\r\n;\r\n\r\n\r\n\r\n\r\nconst modules = { m1: _m1_mjs__WEBPACK_IMPORTED_MODULE_4__.m1fonctions }\r\n\r\nconst dev = process.env.NODE_ENV === 'development'\r\n\r\n/* \r\nvérification que l'origine appartient à la liste des origines autorisées (q'il y en a une)\r\nlocalhost passe toujours\r\n*/\r\nfunction checkOrigin(req) {\r\n  if (!cfg.origins || !cfg.origins.length) return true\r\n  let origin = req.headers['origin']\r\n  if (!origin || origin === 'null') {\r\n    const referer = req.headers['referer'];\r\n    if (referer) {\r\n      const i = referer.indexOf('/', 10);\r\n      if (i !== -1)\r\n        origin = referer.substring(0, i);\r\n    }\r\n  }\r\n  if (!origin || origin === 'null')\r\n    origin = req.headers['host'];\r\n  if (origin && origin.startsWith('http://localhost'))\r\n    origin = 'localhost'\r\n\r\n  return origin && cfg.origins.indexOf(origin) !== -1\r\n}\r\n\r\n// positionne les headers et le status d'une réponse. Permet d'accepter des requêtes cross origin des browsers\r\nfunction setRes(res, status, respType) {\r\n  res.status(status).set({\r\n    'Access-Control-Allow-Origin' : '*',\r\n    'Access-Control-Allow-Methods' : 'GET,POST,PUT,DELETE,OPTIONS',\r\n    'Access-Control-Allow-Headers': 'Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With, X-API-version'\r\n  })\r\n  return res.type(respType ? respType : 'application/octet-stream')\r\n}\r\n\r\nfunction er(c) {\r\n  const l = [\r\n    'Erreur non récupérée : ', // 0\r\n    'Origine non autorisée', // 1\r\n    'Module inconnu', // 2\r\n    'Fonction inconnue', // 3\r\n    'Organisation inconnue', // 4\r\n    'Version d\\'API incompatble', // 5\r\n  ]\r\n  throw new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.E_SRV, l[c])\r\n}\r\n\r\n/*\r\nTraitement générique d'une opération\r\n*/\r\nasync function operation(req, res) {\r\n  let pfx = new Date().toISOString() // prefix de log\r\n  try {\r\n    const isGet = req.method === 'GET'\r\n    // vérification de l'origine de la requête\r\n    if (!checkOrigin(req)) {\r\n      setRes(res, 402).send(er(1))\r\n      return\r\n    }\r\n    // récupération du module traitant l'opération\r\n    const mod = modules[req.params.mod]\r\n    if (!mod) {\r\n      setRes(res, 402).send(er(2))\r\n      return\r\n    }\r\n    // récupétration de la fonction de ce module traitant l'opération\r\n    const f = req.params.func\r\n    const func = mod[f]\r\n    if (!func) {\r\n      setRes(res, 402).send(er(3))\r\n      return\r\n    }\r\n    // reconnaissance de l'organisation\r\n    const cfgorg = cfg.orgs[req.params.org]\r\n    if (!cfgorg) {\r\n      setRes(res, 402).send(er(4))\r\n      return\r\n    }\r\n    // vérification de la version de l'API\r\n    const apiv = req.headers['x-api-version']\r\n    if (apiv && apiv !== _api_mjs__WEBPACK_IMPORTED_MODULE_3__.version) {\r\n      setRes(res, 402).send(er(5))\r\n      return\r\n    }\r\n\r\n    /***************************************************************\r\n    Appel de l'opération\r\n        cfg : configuration relative au code de l'organisation    \r\n        args : objet des arguments\r\n    Retourne un objet result :\r\n    Pour un GET :\r\n        result.type : type mime\r\n        result.bytes : si le résultat est du binaire\r\n    Pour un POST :\r\n        OK : result : objet résultat à sérialiser - HTTP status 200\r\n\r\n    Exception : \r\n        AppExc : AppExc sérialisé en JSON\r\n            code > 0 - erreur fonctionnelle à retourner par l'application\r\n                HTTP status 400\r\n            code < 0 - erreur fonctionnelle à émettre en exception à l'application\r\n                HTTP status 401                   \r\n        Inattendue : Création d'un AppExc avec code < 0 sérialisé en JSON\r\n            HTTP status 402\r\n    *****************************************************************/\r\n    const at = _api_mjs__WEBPACK_IMPORTED_MODULE_3__.argTypes[req.params.func]\r\n    let args\r\n    if (isGet) {\r\n      args = req.query\r\n    } else {\r\n      const type = at && at.length > 0 ? at[0] : null\r\n      args = type ? type.fromBuffer(req.body) : JSON.parse(Buffer.from(req.body).toString())\r\n    }\r\n    pfx += ' func=' + req.params.mod + '/' + req.params.func + ' org=' + req.params.org\r\n    if (dev) console.log(pfx)\r\n    const result = await func(cfgorg, args, isGet)\r\n    if (dev) console.log(pfx + ' 200')\r\n    if (isGet)\r\n      setRes(res, 200, result.type || 'application/octet-stream').send(result.bytes)\r\n    else {\r\n      const type = at && at.length > 1 ? at[1] : null\r\n      const bytes = type ? type.toBuffer(result) : Buffer.from(JSON.stringify(result))\r\n      // const obj = type.fromBuffer(bytes)\r\n      setRes(res, 200).send(bytes)\r\n    }         \r\n  } catch(e) {\r\n    let httpst\r\n    let s\r\n    // exception non prévue ou prévue\r\n    if (e instanceof _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc) { // erreur trappée déjà mise en forme en tant que AppExc \r\n      httpst = e.code === _api_mjs__WEBPACK_IMPORTED_MODULE_3__.F_SRV ? 400 : (e.code === _api_mjs__WEBPACK_IMPORTED_MODULE_3__.X_SRV ? 401 : 402)\r\n      s = e.toString() // JSON\r\n    } else {\r\n      // erreur non trappée : mise en forme en AppExc\r\n      httpst = 402\r\n      s = new _api_mjs__WEBPACK_IMPORTED_MODULE_3__.AppExc(_api_mjs__WEBPACK_IMPORTED_MODULE_3__.E_SRV, e.message, e.stack).toString()\r\n    }\r\n    if (dev) console.log(pfx + ' ' + httpst + ' : ' + s)\r\n    setRes(res, httpst).send(Buffer.from(s))\r\n  }\r\n}\r\n\r\n/*\r\nconst mimetype = {\r\n    \"jpg\": \"image/jpeg\",\r\n    \"jpeg\": \"image/jpeg\",\r\n    \"png\": \"image/png\",\r\n    \"svg\": \"image/image/svg+xml\"\r\n}\r\n*/\r\n\r\nconst dirs = { configdir: './config', dbdir: './databases' }\r\nprocess.argv.forEach((arg) => {\r\n  if (arg.startsWith('configdir=')) dirs.configdir = arg.substring('configdir='.length)\r\n  if (arg.startsWith('dbdir=')) dirs.dbdir = arg.substring('dbdir='.length)\r\n})\r\n\r\nconsole.log('configdir=' + path.resolve(dirs.configdir))\r\nconsole.log('dbdir=' + path.resolve(dirs.dbdir))\r\n\r\n/*\r\nRécupération de la configuration\r\nDans la configuration de chaque environnement, son code est inséré\r\n*/\r\n;(0,_webcrypto_mjs__WEBPACK_IMPORTED_MODULE_2__.setSalts) (fs.readFileSync(path.resolve(dirs.configdir, './salts')))\r\n\r\nconst configjson = fs.readFileSync(path.resolve(dirs.configdir, './config.json'))\r\nlet cfg\r\ntry {\r\n  const options = { fileMustExist: true, verbose: null }\r\n  cfg = JSON.parse(configjson)\r\n  for(const org in cfg.orgs) {\r\n    const e = cfg.orgs[org]\r\n    e.code = org\r\n    e.isDev = dev\r\n    e.db = require('better-sqlite3')(path.resolve(dirs.dbdir, org + '.db3'), options);\r\n  }\r\n} catch(e) {\r\n  throw new Error(' Erreur de parsing de config.json : ' + e.message)\r\n}\r\n\r\n// Les sites appelent souvent favicon.ico\r\nconst favicon = fs.readFileSync(path.resolve(dirs.configdir, './favicon.ico'))\r\n// const deficon = 'data:image/png;base64,' + fs.readFileSync('./anonymous.png', 'base64')\r\n\r\nconst app = express()\r\napp.use(express.json()) // parsing des application/json\r\n\r\n// OPTIONS est toujours envoyé pour tester les appels cross origin\r\napp.use('/', (req, res, next) => {\r\n  if (req.method === 'OPTIONS')\r\n    setRes(res, 200, 'text/plain').send('')\r\n  else\r\n    next()\r\n})\r\n\r\n/**** favicon.ico du sites ****/\r\napp.get('/favicon.ico', (req, res) => {\r\n  setRes(res, 200, 'image/x-icon').send(favicon)\r\n})\r\n\r\n/**** ping du site ****/\r\napp.get('/ping', (req, res) => {\r\n  setRes(res, 200, 'text/plain').send(new Date().toISOString())\r\n})\r\n\r\n/**** appels des opérations ****/\r\napp.use('/:org/:mod/:func', async (req, res) => {\r\n  // push the data to body\r\n  const body = [];\r\n  req.on('data', (chunk) => {\r\n    body.push(chunk);\r\n  }).on('end', async () => {\r\n    req.body = Buffer.concat(body)\r\n    await operation(req, res)\r\n  })\r\n})\r\n\r\n// fonction appelée juste après l'écoute. Initialise les modules sur leurs fonctiopns atStart\r\nfunction atStart() {\r\n  for (const m in modules) {\r\n    const mod =  modules[m]\r\n    if (mod && mod.atStart) mod.atStart(cfg)\r\n  }\r\n}\r\n\r\n/****** starts listen ***************************/\r\n// Pour installation sur o2switch\r\n// https://faq.o2switch.fr/hebergement-mutualise/tutoriels-cpanel/app-nodejs\r\nconst isPassenger = typeof(PhusionPassenger) !== 'undefined'\r\nif (isPassenger) {\r\n  // eslint-disable-next-line no-undef\r\n  PhusionPassenger.configure({ autoInstall: false })\r\n}\r\n\r\nconsole.log('isPassenger:' + isPassenger)\r\n\r\ntry {\r\n  let server\r\n  const port = isPassenger ? 'passenger' : (cfg.port || (!cfg.https ? 8080 : 8443))\r\n  // Création en http ou 'passenger'\r\n  if (!cfg.https)\r\n    server = http.createServer(app).listen(port, () => {\r\n      console.log('HTTP server running on port ' + port)\r\n      try {\r\n        atStart()\r\n      } catch (e) {\r\n        console.log('HTTP server atStart erreur : ' + e.message)\r\n      }\r\n    })\r\n  else {\r\n    // Création en https avec un certificat et sa clé de signature\r\n    const key = fs.readFileSync(path.resolve(dirs.configdir, './privkey.pem'))\r\n    const cert = fs.readFileSync(path.resolve(dirs.configdir, './fullchain.pem'))\r\n    server = https.createServer({key:key, cert:cert}, app).listen(port, () => {\r\n      console.log('HTTP/S server running on port ' + port)\r\n      try {\r\n        atStart()\r\n      } catch (e) {\r\n        console.log('HTTP server atStart erreur : ' + e.message)\r\n      }\r\n    });\t\t\r\n  }\r\n  server.on('error', (e) => { // les erreurs de création du server ne sont pas des exceptions\r\n    console.error('server.js : HTTP error = ' + e.message)\r\n  })\r\n\r\n  const wss = new WebSocket.Server({ server })\r\n  wss.on('connection', (ws, request) => {\r\n    if (checkOrigin(request)) {\r\n      new _session_mjs__WEBPACK_IMPORTED_MODULE_1__.Session (ws, request, wss)\r\n    } else {\r\n      ws.close()\r\n    }\r\n  })\r\n\r\n} catch(e) { // exception générale. Ne devrait jamais être levée\r\n  console.error('server.js : catch global = ' + e.message)\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/server.mjs?");

/***/ }),

/***/ "./src/session.mjs":
/*!*************************!*\
  !*** ./src/session.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSession\": () => (/* binding */ getSession),\n/* harmony export */   \"Session\": () => (/* binding */ Session),\n/* harmony export */   \"syncSessions\": () => (/* binding */ syncSessions)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var _api_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.mjs */ \"./src/api.mjs\");\n/* harmony import */ var _schemas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schemas.mjs */ \"./src/schemas.mjs\");\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/session.mjs\")\r\n\r\nconst now = require('nano-time')\r\n;\r\n\r\n\r\nconst dev = \"development\" === 'development'\r\n\r\nconst sessions = new Map()\r\n\r\nfunction getSession (id) { return sessions.get(id) }\r\n\r\nfunction getdhc() {\r\n  return parseInt(now.micro(), 10)\r\n}\r\n\r\nconst sessionsmortes = new Set()\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nconst gcSessions = setInterval(() => {\r\n  const dh1 = getdhc()\r\n  const max = _api_mjs__WEBPACK_IMPORTED_MODULE_1__.PINGTO * 6 * 10000\r\n  sessionsmortes.clear()\r\n  sessions.forEach((session, sessionId) => {\r\n    const dh2 = session.dhping\r\n    if (dh2 !== 0 && (dh1 - dh2 > max)) sessionsmortes.add(sessionId)\r\n  })\r\n  sessionsmortes.forEach((sid) => {\r\n    sessions.delete(sid)\r\n  })\r\n  sessionsmortes.clear()\r\n}, _api_mjs__WEBPACK_IMPORTED_MODULE_1__.PINGTO * 1000)\r\n\r\n/* Appelé sur l'événement 'connection' reçu du Web Server\r\n- request : requête Http correspondante : on ne sait rien en faire a priori\r\n- wss1 : server web socket\r\n*/\r\nclass Session {\r\n  constructor (ws /*, request, wss1*/) {\r\n    this.ws = ws\r\n    this.dhping = 0\r\n    this.sessionId = null\r\n    this.compteId = null\r\n    this.avatarsIds = []\r\n    this.groupesIds = []\r\n    this.cvsIds = []\r\n    this.nbpings = 0\r\n    this.ws.onerror = (e) => {\r\n      console.log(e)\r\n      if (this.sessionId)\r\n        sessions.delete(this.sessionId)\r\n    }\r\n    this.ws.onclose = (/* e */) => {\r\n      if (this.sessionId)\r\n        sessions.delete(this.sessionId)\r\n      console.log('Fermeture de session détectée:' + this.sessionId)\r\n    }\r\n    this.ws.onmessage = (m) => {\r\n      // seul message reçu : ping avec le sessionid\r\n      this.nbpings++\r\n      const newid = m.data\r\n      const d = new Date()\r\n      this.dhping = d.getTime()\r\n      if (newid !== this.sessionId) {\r\n        // nouvelle session\r\n        if (this.sessionId) {\r\n          sessions.delete(this.sessionId)\r\n        }\r\n        this.sessionId = newid\r\n        sessions.set(newid, this)\r\n        console.log('Ouverture de session reçue: ' + newid + ' / ' + d.toISOString())\r\n      } else {\r\n        if (dev) console.log('Ping reçu: ' + newid + ' / ' + d.toISOString())\r\n      }\r\n      // réponse pong\r\n      if (this.nbpings < 1000000) { // pour tester et ne plus envoyer de pong au delà de N pings\r\n        const pong = { sessionId: newid, dh: getdhc(), syncList: null }\r\n        const buf = _schemas_mjs__WEBPACK_IMPORTED_MODULE_2__.schemas.serialize('synclist', pong)\r\n        this.ws.send(buf)\r\n      }\r\n    }    \r\n  }\r\n\r\n  send (data) {\r\n    this.ws.send(data)\r\n  }\r\n\r\n  sync (/* rows, delobjs */) {\r\n    /* \r\n    liste d'envoi : liste des rows créés / modifiés, liste des objets supprimés\r\n    Uniquement ceux concerné par la session\r\n    */\r\n  }\r\n}\r\n\r\nfunction syncSessions(rows, delobjs) {\r\n  rows.forEach(row => {\r\n    delete row.datax\r\n    delete row.datay\r\n  })\r\n  for (const s of sessions) {\r\n    sessions[s].sync(rows, delobjs)\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://boitessrv/./src/session.mjs?");

/***/ }),

/***/ "./src/webcrypto.mjs":
/*!***************************!*\
  !*** ./src/webcrypto.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SALTS\": () => (/* binding */ SALTS),\n/* harmony export */   \"setSalts\": () => (/* binding */ setSalts),\n/* harmony export */   \"u8ToB64\": () => (/* binding */ u8ToB64),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256),\n/* harmony export */   \"pbkfd\": () => (/* binding */ pbkfd),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"crypter\": () => (/* binding */ crypter),\n/* harmony export */   \"decrypter\": () => (/* binding */ decrypter),\n/* harmony export */   \"decrypterStr\": () => (/* binding */ decrypterStr),\n/* harmony export */   \"genKeyPair\": () => (/* binding */ genKeyPair),\n/* harmony export */   \"crypterRSA\": () => (/* binding */ crypterRSA),\n/* harmony export */   \"decrypterRSA\": () => (/* binding */ decrypterRSA),\n/* harmony export */   \"concat\": () => (/* binding */ concat)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/*********************************************** \r\nIMPLEMENTATION de webcrypto.js EN UTILISANT NODE (crypto)\r\n************************************************/\r\n\r\nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///C:/git/boitessrv/src/webcrypto.mjs\")\r\n\r\nconst crypto = require('crypto')\r\nconst base64js = require('base64-js')\r\n\r\nconst dec = new TextDecoder()\r\n\r\nconst SALTS = new Array(256)\r\nfunction setSalts (a) {\r\n  const b = new Uint8Array(a)\r\n  for (let i = 0; i < 256; i++) {\r\n    SALTS[i] = Uint8Array.prototype.slice.call(b, i * 16, (i + 1) * 16)\r\n  }\r\n}\r\n\r\nfunction u8ToB64 (u8, url) {\r\n  const s = base64js.fromByteArray(u8)\r\n  if (!url) return s\r\n  return s.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_')\r\n}\r\n\r\nfunction b64ToU8 (s) {\r\n  const diff = s.length % 4\r\n  let x = s\r\n  if (diff) {\r\n    const pad = '===='.substring(0, 4 - diff)\r\n    x = s + pad\r\n  }\r\n  return base64js.toByteArray(x.replace(/-/g, '+').replace(/_/g, '/'))\r\n}\r\n\r\nfunction sha256 (buffer) {\r\n  return crypto.createHash('sha256').update(buffer).digest()\r\n}\r\n\r\nasync function pbkfd (secret) {\r\n  return crypto.pbkdf2Sync(secret, SALTS[0], 5000, 32, 'sha256')\r\n}\r\n\r\nfunction random (nbytes) { return crypto.randomBytes(nbytes) }\r\n\r\nasync function crypter (cle, buffer, idxIV) {\r\n  const k = typeof cle === 'string' ? b64ToU8(cle) : cle\r\n  const n = !idxIV ? 0 : (idxIV < 0 ? Number(crypto.randomBytes(1)) : idxIV)\r\n  const cipher = crypto.createCipheriv('aes-256-cbc', k, SALTS[n])\r\n  const x0 = new Uint8Array(1)\r\n  x0[0] = n\r\n  const x1 = cipher.update(buffer)\r\n  const x2 = cipher.final()\r\n  return Buffer.concat([x0, x1, x2])\r\n}\r\n\r\nasync function decrypter (cle, buffer) {\r\n  const k = typeof cle === 'string' ? b64ToU8(cle) : cle\r\n  const decipher = crypto.createDecipheriv('aes-256-cbc', k, SALTS[Number(buffer[0])])\r\n  const x1 = decipher.update(buffer.slice(1))\r\n  const x2 = decipher.final()\r\n  return Buffer.concat([x1, x2])\r\n}\r\n\r\nasync function decrypterStr (cle, buffer) {\r\n  const buf = decrypter(cle, buffer)\r\n  return dec.decode(buf)\r\n}\r\n\r\nasync function genKeyPair () {\r\n  return crypto.generateKeyPairSync('rsa',\r\n    {\r\n      modulusLength: 2048, // the length of your key in bits\r\n      publicKeyEncoding: {\r\n        type: 'spki', // recommended to be 'spki' by the Node.js docs\r\n        format: 'pem'\r\n      },\r\n      privateKeyEncoding: {\r\n        type: 'pkcs8', // recommended to be 'pkcs8' by the Node.js docs\r\n        format: 'pem'\r\n        // cipher: 'aes-256-cbc',   // *optional*\r\n        // passphrase: 'top secret' // *optional*\r\n      }\r\n    })\r\n}\r\n\r\n/* encryption RSA avec la clé publique\r\n  data est un Buffer\r\nconst pad1 = crypto.RSA_PKCS1_OAEP_PADDING_SHA1\r\nconst pad2 = crypto.constants.RSA_PKCS1_OAEP_PADDING\r\nconst pad3 = crypto.constants.RSA_PKCS1_PADDING\r\n*/\r\nconst pad4 = crypto.constants.RSA_NO_PADDING\r\n\r\nasync function crypterRSA (publicKey, data) {\r\n  return crypto.publicEncrypt({ key: publicKey /*, padding: pad3, oaepHash: 'sha256' */ }, data)\r\n}\r\n\r\n/* decryption RSA avec la clé privée\r\n  encryptedData est un Buffer\r\n*/\r\nasync function decrypterRSA (privateKey, encryptedData) {\r\n  // !!! Web API ne peut être décrypté que sans padding !!!\r\n  return crypto.privateDecrypt({ key: privateKey, padding: pad4 /*, oaepHash: 'sha256' */ }, encryptedData)\r\n}\r\n\r\nfunction concat (arrays) {\r\n  // sum of individual array lengths\r\n  const totalLength = arrays.reduce((acc, value) => acc + value.length, 0)\r\n  if (!arrays.length) return null\r\n  const result = new Uint8Array(totalLength)\r\n  let length = 0\r\n  for (const array of arrays) {\r\n    result.set(array, length)\r\n    length += array.length\r\n  }\r\n  return result\r\n}\r\n\r\n/* Tests comparatifs Web API crypto et Node crypto *********\r\nexport async function testWAC () {\r\n  let cle = 'toto est beau'\r\n  let clebin = await pbkfd(cle)\r\n  console.log(u8ToB64(clebin, true))\r\n  const clebin2 = await wcrypt.pbkfd(cle)\r\n  const s1 = u8ToB64(clebin2, true)\r\n  let u8 = b64ToU8(s1)\r\n  const s2 = u8ToB64(clebin2, false)\r\n  console.log(s1)\r\n  console.log(s2)\r\n  u8 = b64ToU8(s1)\r\n  const s3 = u8ToB64(u8, false)\r\n  console.log(s3)\r\n\r\n  cle = enc.encode('toto est beau')\r\n  clebin = await wcrypt.sha256(cle)\r\n  const cle64 = u8ToB64(clebin, true)\r\n\r\n  const sha1 = await sha256(cle)\r\n  const sha2 = await wcrypt.sha256(cle)\r\n  console.log(u8ToB64(sha1, true))\r\n  console.log(u8ToB64(sha2, true))\r\n\r\n  let x = wcrypt.random(16)\r\n  console.log(u8ToB64(x, true))\r\n  x = wcrypt.random(6)\r\n\r\n  const xx = 'https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript'\r\n  x = enc.encode(xx)\r\n  const e1 = await crypter(clebin, x)\r\n  console.log(e1.toString('hex'))\r\n  const d1 = await wcrypt.decrypter(clebin, e1)\r\n  console.log(dec.decode(d1))\r\n  const n = Number(crypto.randomBytes(1)[0])\r\n  const e2 = await wcrypt.crypter(cle64, x, n)\r\n  console.log(e2.toString('hex'))\r\n  const d2 = await decrypter(clebin, e2)\r\n  console.log(dec.decode(d2))\r\n  const e3 = await crypter(cle64, x, n)\r\n  console.log(e3.toString('hex'))\r\n  const d3 = await wcrypt.decrypter(clebin, e3)\r\n  console.log(dec.decode(d3))\r\n\r\n  const kp = await wcrypt.genKeyPair()\r\n  const encRSA1 = await crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA1 : ' + u8ToB64(encRSA1))\r\n  const encRSA2 = await wcrypt.crypterRSA(kp.publicKey, x)\r\n  console.log('encypted data RSA2 : ' + u8ToB64(encRSA2))\r\n\r\n  const decRSA1 = await decrypterRSA(kp.privateKey, encRSA1)\r\n  console.log('decypted data RSA2 : ' + dec.decode(decRSA1))\r\n  const decRSA2 = await wcrypt.decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA2))\r\n\r\n  const decRSA2b = await decrypterRSA(kp.privateKey, encRSA2)\r\n  console.log('decypted data RSA2 : ' + dec.decode(decRSA2b))\r\n  const decRSA1b = await wcrypt.decrypterRSA(kp.privateKey, encRSA1)\r\n  console.log('decypted data RSA1 : ' + dec.decode(decRSA1b))\r\n}\r\n*/\n\n//# sourceURL=webpack://boitessrv/./src/webcrypto.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server.mjs");
/******/ 	
/******/ })()
;